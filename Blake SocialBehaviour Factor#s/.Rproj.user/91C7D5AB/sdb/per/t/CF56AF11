{
    "collab_server" : "",
    "contents" : "#library(foreign)\n#bsbd = read.spss(\"PCA_relationship_qualities.sav\", to.data.frame=TRUE)\n\nlibrary(memisc)\nbsbd <- as.data.frame(as.data.set(spss.system.file('PCA_relationship_qualities.sav')))\n\n\n#write.csv(as.data.frame(bsdb),file='excel.csv')\n\n\nlibrary(psych)\n\nVSS.scree(bsbd[,2:11])\nnfactors(bsbd[,2:11])\n         #,nrotate=\"varimax\")\n\nbvss = VSS(bsbd[,2:11])\nplot(bvss$map)\n\nfa.parallel(bsbd[,2:11],sim=F, error.bars = T, se.bars = F)\n\n\n### construct validity\n\nw.2 = omega(bsbd[,2:11],2,fm='pc')\nw.3 = omega(bsbd[,2:11],3,fm='pc')\n\n\n# library(nFactors)\n# \n# nfn = nScree(x=bsbd[complete.cases(bsbd),2:11], model = 'factors')\n# \n# ncn = nScree(x=bsbd[complete.cases(bsbd),2:11], model = 'components')\n\n\n\n# not appropriate for components...\n# EFA.Comp.Data(Data=bsbd[complete.cases(bsbd),2:11],F.Max=6,\n#               ,Graph=TRUE)\n\n\n\n# Hull method?\n\n\n\n\n##### Actual extractions\n\n\n#sb.f2 = fa(bsbd[,2:11], nfactors = 2, rotate=\"varimax\", n.iter=1000, fm='ml')\nsb.pc2 = principal(bsbd[,2:11], nfactors = 2, rotate=\"varimax\") \n# replace current solution in text (???)\n\n#sb.f3 = fa(bsbd[,2:11], nfactors = 3, rotate=\"varimax\", n.iter=1000)\nsb.pc3 = principal(bsbd[,2:11], nfactors = 3, rotate=\"varimax\")\n\nsb.f4 = fa(bsbd[,2:11], nfactors = 4, rotate=\"varimax\")\nsb.pc4 = principal(bsbd[,2:11], nfactors = 4, rotate=\"varimax\")\n\n### how good oblique?\n\nsb.f2.ob = fa(bsbd[,2:11], nfactors = 2, rotate=\"oblimin\")\n#sb.pc2 = principal(bsbd[,2:11], nfactors = 2, rotate=\"varimax\")\n# replace current solution in text (???)\n\nsb.f3.ob = fa(bsbd[,2:11], nfactors = 3, rotate=\"oblimin\")\n#sb.pc3 = principal(bsbd[,2:11], nfactors = 3, rotate=\"varimax\")\n\nsb.f3.ob$chi\nsb.f2.ob$chi\nsb.f2$chi\n\n####### Revisions\nKMO(bsbd[,2:11])\ncortest.bartlett(bsbd[,2:11])\n\ncor(bsbd[,2:11], use = 'na.or.complete')\n\n\n# Tucker congruence\nfactor.congruence(sb.pc2$loadings,sb.pc3$loadings)\n\n\n\n# Bootstrapped PCA\n\nboot.3 <- PCAboot(bsbd[,-1], nf = 3, permutations=10) #,rot=\"varimax\")\nboot.2 <- PCAboot(bsbd[,-1], nf = 2, rot=\"varimax\")\n\n\n# x = bsbd[,-1]\n# nf = 2\n# rot = 'varimax'\n\nPCAboot <- function (x, permutations=1000, nf){\n  pcnull <- pca(x, nfactors=nf, rotate='varimax')\n  res <- pcnull$loadings[,1]\n  # bsresults = matrix( rep.int(NA, permutations*NROW(res)) ,\n  #                     nrow=permutations, ncol=NROW(res) )\n  N <- ncol(x)\n  bsresults <- array(NA,dim=c(permutations,N,nf))\n  for (i in 1:permutations) {\n    pc <- pca(x[sample(N, replace=TRUE), ], nfactors=nf) #, rotate=rot )\n    pred <- predict(pc, data = x)\n    r <-  cor(pcnull$scores, pred,use=\"pairwise.complete.obs\")\n    k <- apply(abs(r), 2, which.max)\n    reve <- sign(diag(r[k,]))\n    sol <- pc$loadings[,k]\n    #sol <- sweep(sol, 2, reve, \"*\")\n    bsresults[i,,] <- sol\n  }\n  #print(apply( bsresults, 2, quantile, c(0.05, 0.95) ))\n  return(bsresults)\n} \n\n\nlibrary(boot)\n\n# this version seems to work the best\nkey2 <- matrix(c(1,1,1,1,1,1,1,1,0,0,\n                0,0,0,0,0,0,0,0,1,1),ncol=2)\nkey3 <- matrix(c(1,1,1,0,0,0,0,0,0,0,\n                 0,0,0,1,1,1,1,1,0,0,\n                 0,0,0,0,0,0,0,0,1,1),ncol=3)\n  \nperms = 100\nnf = 3\n\nefa <- function(data, indices, key) {\n  dd <- data[indices,]\n  bsresults <- array(NA,dim=c(perms,ncol(data),nf))\n  fitefa <- pca(r=dd, nfactors=3, rotate = \"varimax\") #, keys = key2)\n  #fitefa <- target.rot(pca(r=dd, nfactors=nf) , keys = key3)\n  return(c(fitefa$loadings))\n  #bsresults[i,,] <- fitefa\n  \n}\nepcaresults <- boot(data=bsbd[,-1], statistic=efa, R=perms)\n\n\n# getPrcStat <- function (bsbd,vname,pcnum,nf){\n#   prcs <- pca(bsbd[,-1],nf) # returns matrix\n#   return(prcs$loadings)   # pick out the thing we need\n# }\n# \n# bootEst <- function(df,d){\n#   sampledDf <- df[ d, ]  # resample dataframe \n#   return(getPrcStat(sampledDf,nf=3))\n# }\n# \n# bootOut <- boot(bsbd,bootEst,R=100)\n# boot.ci(bootOut,type=c(\"basic\"))\n\n\n# pcaLoad <- function(x, ...){\n#   z <- pca(x, ...)\n#   return(pca$loadings)\n#   \n# }\n# \n# b.obj.2 <- boot(bsbd[,-1],pcaLoad, R=999, nfactor=2)\n\n\n\n### SEM???\nlibrary(lavaan)\nlibrary(semPlot)\n\nmod2 <-'\n  # measurement model\npc1 =~ spatialproximity + grooming + groom_symmetry + \navoidstaysymmetry + foodshare + food_share_symmetry + coalitions + socialforaging\npc2 =~ conflict + conflict_symmetry\n\n# regressions\npc1 ~~ 0*pc2\n'\n\nmod3.ob <-'\n  # measurement model\npc1 =~ spatialproximity + grooming + groom_symmetry\npc3 =~ avoidstaysymmetry + foodshare + food_share_symmetry + coalitions + socialforaging\npc2 =~ conflict + conflict_symmetry\n\n# regressions\npc1 ~~ 0*pc2\npc3 ~~ 0*pc2\n'\n\nmod3 <-'\n  # measurement model\npc1 =~ spatialproximity + grooming + groom_symmetry\npc3 =~ avoidstaysymmetry + foodshare + food_share_symmetry + coalitions + socialforaging\npc2 =~ conflict + conflict_symmetry\n\n# regressions\npc1 ~~ 0*pc2\npc1 ~~ 0*pc3\npc3 ~~ 0*pc2\n'\n\nmod2.ml <-'\n  # measurement model\npc1 =~ spatialproximity + grooming + groom_symmetry\npc3 =~ avoidstaysymmetry + foodshare + food_share_symmetry + coalitions + socialforaging\npc2 =~ conflict + conflict_symmetry\npcHi =~ pc1 + pc3\n\n# regressions\n# pc1 ~~ 0*pc2\n# pc1 ~~ 0*pc3\n# pc3 ~~ 0*pc2\npcHi ~~ 0*pc2\n\npc1 ~~ 1*pc1\npc2 ~~ 1*pc2\npc3 ~~ 1*pc3\npcHi ~~ 1*pcHi\n'\n\nmod2.bi <- '\n# measurement model\npc1 =~ spatialproximity + grooming + groom_symmetry\npc3 =~ avoidstaysymmetry + foodshare + food_share_symmetry + coalitions + socialforaging\npc2 =~ conflict + conflict_symmetry\npcBi =~ spatialproximity + grooming + groom_symmetry + \navoidstaysymmetry + foodshare + food_share_symmetry + coalitions + socialforaging\n\n# regressions\npc1 ~~ 0*pc2\npc1 ~~ 0*pc3\npc3 ~~ 0*pc2\npcBi ~~ 0*pc2\npcBi ~~ 0*pc3\npcBi ~~ 0*pc1\n\npc1 ~~ 1*pc1\npc2 ~~ 1*pc2\npc3 ~~ 1*pc3\npcBi ~~ 1*pcBi\n'\n\nmod3.pseudo.bi <- '\n# measurement model\npc3 =~ avoidstaysymmetry + foodshare + food_share_symmetry + coalitions + socialforaging\npc2 =~ conflict + conflict_symmetry\npcBi =~ spatialproximity + grooming + groom_symmetry + pc3\n\n\n# regressions\npc3 ~~ 0*pc2\npcBi ~~ 0*pc2\npcBi ~~ 0*pc3\n\n\npc2 ~~ 1*pc2\npc3 ~~ 1*pc3\npcBi ~~ 1*pcBi\n'\n\nbsbd[,2:11] = scale(bsbd[,2:11])\n\n\nfit2 <- sem(mod2, data=bsbd)\nfit3 <- sem(mod3, data=bsbd)\nfit3.ob <- sem(mod3.ob, data=bsbd)\nfit2.ml <- sem(mod2.ml, data=bsbd, missing='fiml')\nfit2.bi <- sem(mod2.bi, data=bsbd, missing='fiml')\nfit3.p.bi<- sem(mod3.pseudo.bi, data=bsbd, missing='fiml') # this model is unusual - it is unclear to me if it is okay to do something like this\n\nsemPaths(fit2, what='std')\nsemPaths(fit3, what='std')\nsemPaths(fit3.ob, what='std')\nsemPaths(fit2.ml, what='std')\nsemPaths(fit3.p.bi, what='std')\n\nsummary(fit2.ml, fit.measures=T)\n\nfitMeasures(fit2, c(\"chisq\", \"df\", \"pvalue\", \"cfi\", \"rmsea\"))\nfitMeasures(fit3, c(\"chisq\", \"df\", \"pvalue\", \"cfi\", \"rmsea\"))\nfitMeasures(fit2.bi,  c(\"chisq\", \"df\", \"pvalue\", \"cfi\", \"rmsea\"))\nfitMeasures(fit3.ob, c(\"chisq\", \"df\", \"pvalue\", \"cfi\", \"rmsea\"))\nfitMeasures(fit2.ml, c(\"chisq\", \"df\", \"pvalue\", \"cfi\", \"rmsea\"))\nfitMeasures(fit3.p.bi, c(\"chisq\", \"df\", \"pvalue\", \"cfi\", \"rmsea\"))\n\n",
    "created" : 1473150980032.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1395071020",
    "id" : "CF56AF11",
    "lastKnownWriteTime" : 1473418791,
    "last_content_update" : 1473418791003,
    "path" : "C:/Users/s1229179/GitHub/R/Blake SocialBehaviour Factor#s/basic_anal.R",
    "project_path" : "basic_anal.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}