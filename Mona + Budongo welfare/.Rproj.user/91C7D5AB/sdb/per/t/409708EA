{
    "collab_server" : "",
    "contents" : "\n\n\n\nwf$z_wfswb[1:18] = scale(wf$welfareswb[1:18])\nwf$z_wfswb[19:36] = scale(wf$welfareswb[19:36])\n\nwf$time <- as.factor(wf$time)\n\nwf$DMpartic = as.factor(c(2,0,2,1,1,2,0,2,0,0,2,1,0,1,1,1,0,0,\n                          2,0,2,1,1,2,0,2,0,0,2,1,0,1,1,1,0,0))\n\nwf$DMpartic = as.factor(c(1,0,1,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,  # 10\n                          1,0,1,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0))\n\n### Unsplit\n\nlibrary(lattice)\nxyplot(welfareswb ~ time, data = wf, type = 'l')\n\n\nt.test(welfareswb ~ time, data = wf)\n\n\n### Individual\n\ninteraction.plot(wf$time, wf$Chimp, wf$z_wfswb, type='b', col = c(1:18))\n\n\n\n\nlibrary(ggplot2)\n\nggplot(wf, aes(time, z_wfswb,colour=Chimp)) +\n  geom_line() + geom_point()\n\nwf$EWpartic = as.factor(c(1,0,1,0,1,1,0,1,0,0,0,1,0,0,1,0,0,0,1,0,1,0,1,1,0,1,0,0,0,1,0,0,1,0,0,0))\n\n# never involved {0}\n# RE, SO, HE, LI, DA, LU, KD\n\n# approach but never complete session {1}\n# EM, LO, PA, PE, Q, EV;\n\n# complete session {2}\n# ED, LB, KL, FK, CI\n\n\nggplot(wf, aes(time, welfareswb,colour=EWpartic)) +\n  geom_abline() + geom_point()\n\n\ninteraction.plot(wf$time, wf$EWpartic, wf$z_wfswb, type='b')\n\ninteraction.plot(wf$time, wf$DMpartic, wf$z_wfswb, type='b')\n\n                    #      CI  DA  ED  EM  EV  FK  HE  KL  KD  LI  LB  LO  LU  PA  PE  Q   RE  SO\nwf$Compartic = as.factor(c(0,  0,  1,  0,  1,  1,  0,  1,  0,  0,  1,  0,  0,  0,  1,  0,  0,  0, #LO?\n                           0,  0,  1,  0,  1,  1,  0,  1,  0,  0,  1,  0,  0,  0,  1,  0,  0,  0))\n\ninteraction.plot(wf$time, wf$Compartic, wf$z_wfswb, type='b')\n\n# t.test(wf$welfareswb[wf$time==1],wf$welfareswb[wf$time==2])\n\nanova.DM <- aov(z_wfswb ~ DMpartic * time, data=wf)\n\nanova.comp <- aov(z_wfswb ~ Compartic * time, data=wf)\n\nsummary(anova.DM)\nTukeyHSD(anova.DM)\n\n###\nwf.ag<- with(wf , aggregate(welfareswb, \n                            list(participation=DMpartic, time=time), mean))\nwf.ag$se<- with(wf, aggregate(welfareswb,\n                              list(participation=DMpartic, time=time), sd))[,3]\n\nwf.ag$time = as.numeric(wf.ag$time)\nwf.ag$time[wf.ag$participation == 1] = wf.ag$time[wf.ag$participation == 1] + 0.1\n\ngp <- ggplot(data=wf.ag, aes(x=time, y=x, colour=participation, group=participation)) \ngp + geom_line(aes(linetype=participation), size=.6) + \n  geom_point(aes(shape=participation), size=3) + \n  geom_errorbar(aes(ymax=x+se, ymin=x-se), width=.1) +\n  labs(x = \"Time point\", y = 'Welfare') +\n  scale_x_discrete(limits=c(\"1\", \"2\"))\n\n\n\nlibrary(lme4)\n\nanov.DM = aov(welfareswb ~ DMpartic * time, data=wf)\n\n# HB-S main model\nlmm.DM <- lmer(welfareswb ~ DMpartic * time + (1|Chimp), data=wf)\n\nsummary(lmm.DM)\nconfint(lmm.DM, method='boot')\n\nlmm.DM.0 <- lmer(welfareswb ~ 1 + (1|Chimp), data=wf)\n\n\nlmm.comp <- lmer(z_wfswb ~ Compartic * time + (1|Chimp), data=wf)\n\n\n\n### Bootstrapping\n\n# lmer\n\nmySumm <- function(.) { s <- sigma(.)\nc(beta =getME(., \"beta\"), sigma = s, sig01 = unname(s * getME(., \"theta\"))) }\n(t0 <- mySumm(lmm.comp)) # just three parameters\n\nset.seed(101)\nboot.1 = bootMer(lmm.comp, mySumm, nsim=100)\n\nhead(as.data.frame(boot.1))\n\n## Extract all CIs (somewhat awkward)\nbCI.tab <- function(b,ind=length(b$t0), type=\"perc\", conf=0.95) {\n  btab0 <- t(sapply(as.list(seq(ind)),\n                    function(i)\n                      boot.ci(b,index=i,conf=conf, type=type)$percent))\n  btab <- btab0[,4:5]\n  rownames(btab) <- names(b$t0)\n  a <- (1 - conf)/2\n  a <- c(a, 1 - a)\n  pct <- stats:::format.perc(a, 3)\n  colnames(btab) <- pct\n  return(btab)\n}\nbCI.tab(boot.1)\n\n\n\n# ANOVA bootstrapping\n\n# define function to compute and return test statistics of interest\npermDiff <- function(wf, indices){\n  wf$z_wfswb <- wf$z_wfswb[indices]\n  anova.comp <- aov(z_wfswb ~ Compartic * time, data=wf)\n  #model <- glm(job ~ cset*(r1 + r2), family=binomial, data=dat)\n  return(coefs = coef(anova.comp))\n}\n\nresamples <- 1000\nresults2 <- boot(data=wf, statistic=permDiff, R=resamples, sim=\"permutation\"\n                 )\n# plot sampling distributions\nlayout(cbind(1:2,3:4))\napply(results2$t, 2, function(x){plot(density(x)); abline(v=0);})\nlayout(1)\n\n# get p-values\npVals <- sapply(1:4, function(x){\n  mean(results2$t[,x] > abs(results2$t0[x]) | results2$t[,x] < -1*abs(results2$t0[x]))\n})\npVals\n\n# display with default glm results\ncbind(coef(anova.comp), permP=pVals)\n\n\n\n\n# ANOVA permutation\n\nobserved_F_value <- anova(lm(z_wfswb ~ DMpartic * time, data=wf))$\"F value\"[1]\n\nn <- 10000\npermutation_F_values <- numeric(length=n)\n\nfor(i in 1:n){\n  # note: the sample function without extra parameters defaults to a permutation\n  temp_fit <- anova(lm(z_wfswb ~ sample(DMpartic) * time,data=wf))\n  permutation_F_values[i] <- temp_fit$\"F value\"[1]\n}\n\nhist(permutation_F_values, xlim=range(c(observed_F_value, permutation_F_values)))\nabline(v=observed_F_value, lwd=3, col=\"red\")\ncat(\"P value: \", sum(permutation_F_values >= observed_F_value), \"/\", n, \"\\n\", sep=\"\")\n\n\n\n# Model-based resampling\n\n\nP     <- 4\nNj    <- c(41, 37, 42, 40)\nmuJ   <- rep(c(-1, 0, 1, 2), Nj)\ndfCRp <- data.frame(IV=factor(rep(LETTERS[1:P], Nj)),\n                    DV=rnorm(sum(Nj), muJ, 6))\n\nanBase <- anova(lm(z_wfswb ~ Compartic * time, data=wf))\nFbase  <- anBase[\"IV\", \"F value\"]\n(pBase <- anBase[\"IV\", \"Pr(>F)\"])\n\n\n\n## the below does not work\n\nB-nova <- boot.anova(wf, z_wfswb ~ Compartic * time)\n\nalias(z_wfswb ~ Compartic * time, data=wf)\n\n\n####### Functions #######\n\nrequire(car)\nrequire(boot)\n\n# Bootstrapped AN(C)OVA Options -------------------------------------------\n#\n# formula:      Formula for AN(C)OVA model\n#\n# conf.int:     Confidence intervals (default = 0.95)\n#\n# dec:          Number of decimal places (default = 3)\n#\n# reps:         Number of bootstrap replications (default = 1000)\n\n# Bootstrap statistic -----------------------------------------------------\n\nanboot <- function(formula, data, i){\n  \n  data.resamp <- data[i,] # Resample rows\n  \n  fit <- lm(formula, data.resamp)\n  \n  f.coef <- Anova(fit, type = 2)[[\"F value\"]] # Extract F-values\n  \n  return <- c(f.coef)\n}\n\n# Function to run bootstrap and provide output ----------------------------\nboot.anova <- function(data, formula, conf.int = 0.95, dec = 2, reps = 1000) {\n  \n  # Fit non-bootstrapped ANOVA to obtain Sum Sq and df\n  lm.fit <- lm(formula, data = data)\n  # Get DV name\n  dv.name <- colnames(model.frame(lm.fit))[1]                    \n  # Get IV names\n  iv.names <- attr(lm.fit$terms , \"term.labels\")\n  \n  # Fit ANOVA model with Type III Sum of Squares\n  anova.fit <- Anova(lm.fit, type = 2)\n  \n  \n  # Call anboot function\n  anboot.run <- boot(statistic = anboot, formula = formula, data = data, R = reps)\n  \n  f.ssq <- anova.fit[[\"Sum Sq\"]]           # Sum of Squares (Type III)    \n  f.values <- summary(anboot.run)$original # F-values\n  f.se <- summary(anboot.run)$bootSE       # Bootstrap SE\n  f.z <- f.values/f.se                     # z-value\n  f.z.p <- 2*pnorm(-abs(f.z))              # Pr(>|z|)\n  f.df <- anova.fit[[\"Df\"]]                # df\n  \n  f.crit <- NULL # To prevent errors\n  \n  # Critical F-Value (excludes the 'Residuals' term)\n  for(i in 1:(length(f.df)-1)){\n    f.crit[i] <- qf(conf.int, f.df[i], f.df[length(f.df)])\n  }\n  \n  # Get Bootstrapped confidence intervals\n  ci.lower <- NULL\n  ci.upper <- NULL\n  \n  for(i in 1:length(f.values)){\n    boot.bca <- boot.ci(anboot.run, index = i, type = \"bca\", conf = conf.int)$bca\n    ci.lower[i] <- boot.bca[4]\n    ci.upper[i] <- boot.bca[5]     \n  }\n  \n  # P-value stars\n  fstar <- NULL\n  \n  for(i in 1:length(na.omit(f.z.p))) {\n    if(f.z.p[i] < .001) {\n      fstar[i] <- \"***\"\n    } else if(f.z.p[i] < .01) {\n      fstar[i] <- \"**\"\n    } else if(f.z.p[i] < .05) {\n      fstar[i] <- \"*\"\n    } else if(f.z.p[i] < .10){\n      fstar[i] <- \".\"\n    } else {\n      fstar[i] <- \"\"\n    }\n  }\n  \n  # Column names\n  cnames <- c(\"Sum Sq\", \"Df\", \"F value\", \"SE\", \"LB\", \"UB\", \"Crit F\", \"z\", \"Pr(>|z|)\", \"\")\n  \n  # Row names\n  rnames <- c(\"(Intercept)\", iv.names, \"Residuals\")\n  \n  # Turn warnings off as the variables are not equal length when creating output.df\n  options(warn = -1)\n  \n  # Create data frame to use as output\n  output.df <- as.data.frame(cbind(round(f.ssq, dec), \n                                   f.df, \n                                   format(round(f.values, dec), dec), \n                                   format(round(f.se, dec), dec), \n                                   format(round(ci.lower, dec), dec), \n                                   format(round(ci.upper, dec), dec), \n                                   format(round(f.crit, dec), dec),\n                                   format(round(f.z, dec), dec), \n                                   signif(f.z.p, 3),\n                                   fstar))\n  \n  \n  # Remove redundant values for the Residuals row\n  output.df[nrow(output.df), 3:10] <- NA\n  \n  # Set column and row names\n  colnames(output.df) <- cnames\n  rownames(output.df) <- rnames\n  \n  \n  # Print results\n  cat(\"BCa Bootstrap Anova Table (Type III tests)\", \n      \"\\n\",\n      \"\\n\", \"Response: \", dv.name,\n      \"\\n\",\n      sep =\"\")\n  \n  print(as.matrix(output.df), justify = \"right\", na.print = \"\" , quote = FALSE )\n  \n  cat(\"---\",\n      \"\\n\", \"Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1)\",\n      sep = \"\")\n  \n  # Turn warnings on\n  options(warn = 0)\n}",
    "created" : 1462453596398.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4019994238",
    "id" : "409708EA",
    "lastKnownWriteTime" : 1466509852,
    "last_content_update" : 1466509852169,
    "path" : "C:/Users/s1229179/GitHub/R/Mona + Budongo welfare/Hannah.R",
    "project_path" : "Hannah.R",
    "properties" : {
        "tempName" : "Untitled2"
    },
    "relative_order" : 7,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}