{
    "contents" : "covTest=function(fitobj,x,y,sigma.est=\"full\",status=NULL, maxp=min(nrow(x),ncol(x))){\n  # compute sequence of test statistics, for  cov test,\n  # sigma.est is method of estimation for sigma- \"full\" or a numeric value (known)\n  # returns results in matrix res, \n  # sigma=estimate of sigma a\n  s4=substring(fitobj$call,1,4)[1]\n  s7=substring(fitobj$call,1,7)[1]\n  s8=substring(fitobj$call,1,8)[1]\n  if(s4==\"lars\"& s7!=\"lars.en\"  &s8!=\"lars.glm\") {calltype=\"lars\";family=\"gaussian\"}\n  if(s7==\"lars.en\") {calltype=\"lars.en\";family=\"gaussian\"}\n  if(s8==\"lars.glm\") {calltype=\"lars.glm\";family=fitobj$family}\n  if(family==\"cox\")\n    stop(\"Cox model not yet implemented\")\n  if(calltype==\"lars\"){\n    if(fitobj$type!=\"LASSO\"){stop(\"Call to Lars must use type='LASSO'\")}\n  }\n  if(calltype==\"lars\"){type=\"lars\"}\n  if(calltype==\"lars.en\") {type=\"lars.en\"}\n  if(calltype==\"lars.glm\"){type=\"lars.glm\"}\n  if(calltype==\"lars.glm\" & sigma.est==\"full\"){\n    sigma.est=1\n    cat(\"glm model; sigma set to 1\",fill=TRUE)\n  }\n  n=nrow(x)\n  p=ncol(x)\n  my=mean(y)\n  \n  lambda.min.ratio = ifelse(nrow(x)<ncol(x),0.1,0.0001)\n  \n  jlist=unlist(fitobj$act)\n  if(type==\"lar\") lamlist=c(fitobj$lambda,0)\n  if(type==\"lars.en\") lamlist=c(fitobj$lambda,0)\n  if(type==\"lars.glm\") lamlist=c(fitobj$lambda,0)\n  \n  maxp.call=maxp\n  \n  maxp=length(jlist)\n  maxp=min(maxp,which(lamlist==0))\n  maxp=min(maxp,maxp.call)\n  jlist=jlist[1:maxp]\n  \n  cov0=cov=sig=rep(NA,maxp)\n  \n  yy=y-my\n  \n  if(family==\"gaussian\"){\n    glmobj=glmnet(x,y,family=\"gaussian\",standardize=T, alpha = 0.7,lambda.min.ratio=0.00001,  nlambda=1000)\n    #     glmobj=glmnet(x,y,family=\"gaussian\",standardize=fitobj$standardize,lambda.min.ratio=lambda.min.ratio)\n  }\n  if(family==\"cox\"){\n    glmobj=glmnet(x,Surv(y,status),family=\"cox\",standardize=fitobj$standardize, lambda.min.ratio=lambda.min.ratio)\n  }\n  \n  \n  if(family==\"cox\"){\n    junk=calcz02(x,y,status)\n    sc=junk$sceta;inf=junk$infeta;\n    miinf=misqrt((t(inf)+inf)/2)\n    yy=t(sc)%*%miinf\n  }\n  \n  for(j in 1:maxp){\n    if(jlist[j]>0){\n      #cat(j,fill=T)\n      lambda=lamlist[j+1]\n      if(type==\"lar\") yhat=predict(fitobj,x,s=lambda,type=\"fit\",mode=\"lam\")$fit\n      if(type==\"lars.en\") yhat=(1+fitobj$lambda2)*predict.lars.en(fitobj,x,lambda)\n      if(type==\"lars\" & family==\"gaussian\") {\n        yhat=as.vector(predict(glmobj,x,type=\"link\",s=lambda/n))\n      }\n      if(type==\"lars.glm\" & family==\"cox\"){\n        yhat=as.vector(predict(glmobj,x,type=\"link\",s=lambda/n))\n      }\n      cov[j]=sum(yy*yhat)\n      \n      if(j==1){cov0[j]=0}\n      if(j>1){\n        tt0=which(fitobj$beta[j,]!=0)\n        \n        if(type==\"lar\"){\n          aa=update(fitobj,x=x[,tt0,drop=F])\n          yhat0=predict(aa,x[,tt0],type=\"fit\",s=lambda,mode=\"lam\")$fit\n        }\n        if(type==\"lars.en\"){\n          #  aa=lars.en(x[,tt0,drop=F],y,lambda2=fitobj$lambda2,\n          #     normalize=fitobj$normalize)\n          aa=update(fitobj, x=x[,tt0,drop=F])\n          yhat0=(1+fitobj$lambda2)*predict.lars.en(aa,x[,tt0],lambda)\n        }\n        if(type==\"lars\"){\n          if(family==\"gaussian\")  {\n            # this next line because glmnet now bombs if x has one col\n            if(length(tt0)==1){tt0=c(tt0,tt0)}\n            #glmobj0=glmnet(x[,tt0,drop=F],y,family=\"gaussian\",standardize=fitobj$standardize,lambda.min.ratio=lambda.min.ratio)\n            glmobj0=glmnet(x[,tt0,drop=F],y,family=\"gaussian\",standardize=T, alpha = 0.7,lambda.min.ratio=0.00001,  nlambda=1000)\n            yhat0=as.vector(predict(glmobj0,x[,tt0,drop=F],type=\"link\",s=lambda/n))\n          }\n          if(family==\"cox\"){  \n            if(length(tt0)==1){tt0=c(tt0,tt0)}\n            glmobj0=glmnet(x[,tt0,drop=F],Surv(y,status),family=\"cox\",standardize=fitobj$standardize,lambda.min.ratio=lambda.min.ratio)\n            yhat0=as.vector(predict(glmobj0,x[,tt0,drop=F],type=\"link\",s=lambda/n))\n          }\n        }\n        cov0[j]=sum(yy*yhat0)\n      }\n    }\n  }\n  \n  if(is.numeric((sigma.est))){\n    sigma=sigma.est;sigma.type=\"known\";null.dist=\"Exp(1)\"\n    if(sigma.est<=0){stop(\"sigma.est must be positive\")}\n  }\n  if(sigma.est==\"full\"){\n    if(nrow(x)<ncol(x)+1) stop(\"Number of observations must exceed number of variables,\n                               when sigma.est is `full; you need to specify a numeric value for sigma.est\")\n    sigma.type=\"unknown\"\n    aaa=lsfit(x,y)\n    sigma=sqrt(sum(aaa$res^2)/(n-p))\n    np=n-p\n    null.dist=paste(\"F(2,\",as.character(np),\")\",sep=\"\")\n  }\n  tt=((cov-cov0)/sigma^2)\n  \n  if(sigma.type==\"known\"){out=cbind(jlist,tt,1-pexp(tt,1));dimnames(out)[[2]]=c(\"Predictor_Number\",\"Drop_in_covariance\",\"P-value\")}\n  if(sigma.type==\"unknown\"){out=cbind(jlist,tt,1-pf(tt,2,n-p));dimnames(out)[[2]]=c(\"Predictor_Number\",\"Drop_in_covariance\",\"P-value\")}\n  dimnames(out)[[1]]=rep(\"\",nrow(out))\n  return(list(results=round(out,4),sigma=round(sigma,4),null.dist=null.dist))\n}\n\nlars.glm=function(x,y,status=NULL,family=c(\"binomial\",\"cox\"),standardize=TRUE,frac.arclength=.1){\n  #\n  # extract (approximate) lars path for lasso-penalized glms\n  \n  call=match.call()\n  family=match.arg(family)\n  p=ncol(x)\n  n=nrow(x)\n  if(family==\"binomial\")  {\n    a=glmpath(x,y,family=\"binomial\",lambda2=0,standardize=standardize,frac.arclength=frac.arclength)\n    b=a$b.pred[,-1,drop=F]\n  }\n  if(family==\"cox\") {\n    d=list(x=x,time=y,status=status)\n    a=coxpath(d,lambda2=0)\n    a$family=\"cox\"\n    b=a$b.pred\n  }\n  act=a$act\n  ind=rep(FALSE,length(act))\n  for(k in 1:length(act)){\n    if(!is.null(act[[k]])){\n      ind[k]=TRUE\n    }\n  }\n  \n  lambda=a$lambda[ind]\n  \n  beta=b[ind,,drop=F]\n  a0=NULL\n  if(family==\"binomial\") a0=a$b.pred[ind,1]\n  lambda=a$lambda[ind]\n  maxp=nrow(beta)\n  return(list(beta=beta,a0=a0,lambda=lambda,act=act,maxp=maxp,family=family,frac.arclength=frac.arclength,call=call,pathobj=a))\n}\n\npredict.lars.glm=function(object,x,lambda,time=NULL,status=NULL,...){\n  if(object$pathobj$family[[1]]==\"binomial\") yhat=predict.glmpath(object$pathobj,x,s=lambda,mode=\"lambda\",type=\"link\")\n  if(object$pathobj$family[[1]]==\"cox\") {\n    data=list(x=x,time=time,status=status)\n    yhat=predict.coxpath(object$pathobj,data,s=lambda,mode=\"lambda\",type=\"lp\")\n  }\n  return(yhat)\n}\n\nlars.en=function(x,y,lambda2,normalize=TRUE){\n  call=match.call()\n  n=nrow(x)\n  p=ncol(x)\n  mx=colMeans(x)\n  sdx=sqrt(apply(x,2,var))\n  if(normalize){\n    x=scale(x,mx,sdx)\n    y=y-mean(y)\n  }\n  xs=x\n  ys=y\n  if(lambda2>0){\n    xs=rbind(xs,sqrt(lambda2)*diag(p))\n    ys=c(ys,rep(0,p))\n  }\n  a=lars(xs,ys,normalize=F)\n  return(list(beta=a$beta,larsobj=a,mx=mx,sdx=sdx,normalize=normalize,lambda=a$lambda,lambda2=lambda2,act=a$act,call=call))\n}\n\npredict.lars.en=function(object, x,lambda,...){\n  if(object$normalize){\n    x=scale(x,object$mx,object$sdx)\n  }\n  yhat=predict(object$larsobj,x,s=lambda,type=\"fit\",mode=\"lambda\")$fit\n  return(yhat)\n}\n\ncalcz02=function(x,y,status){\n  a=coxph(Surv(y,status)~x,iter.max=0)\n  aa=residuals(a,type=\"score\")\n  scbeta=colSums(aa)\n  sceta=x%*%scbeta\n  infbeta=ginv(a$var)\n  infeta=x%*%infbeta%*%t(x)\n  #temp=msqrt(infeta)\n  #z=as.vector(ginv(temp)%*%sceta)\n  return(list(sceta=sceta,infeta=infeta))\n}\n\nmisqrt=\n  function(x)\n  {\n    if(length(x) == 1.) {\n      ans <- sqrt(x)\n    }\n    if(length(x) > 1.) {\n      a <- eigen(x)\n      p <- a$vectors\n      d <- a$values\n      d[d < 1e-05] <- 0.\n      dd=1/d;dd[d==0]=0\n      ans <- p %*% diag(sqrt(dd)) %*% t(p)\n    }\n    return(ans)\n  }",
    "created" : 1447770880538.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "406166003",
    "id" : "B889150C",
    "lastKnownWriteTime" : 1447851902,
    "path" : "C:/Users/s1229179/GitHub/R/Mona + Budongo welfare/covTest.R",
    "project_path" : "covTest.R",
    "properties" : {
        "tempName" : "Untitled2"
    },
    "relative_order" : 10,
    "source_on_save" : false,
    "type" : "r_source"
}