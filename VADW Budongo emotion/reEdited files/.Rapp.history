scans = read.csv("combined old style corrected KS 210513 1558.csv", header=TRUE)
head(scans)
taking out extra rows#
subscans = subset(scans, scans$Qafzeh!="")#
subscans = subset(subscans, Qafzeh != "Qafzeh")#
colnames(subscans)[1] <- 'date'#
# builds the basic data.frame that we're to add to#
MLMformat = data.frame(date = character(0), observationNumber = integer(0), scanNumber = integer(0),#
                       chimp = character(0), behaviour = character(0),#
                       stringsAsFactors = TRUE)#
#colnames(MLMformat) #<- c('date','observationNumber','scanNumber','chimp','behaviour')#
#test = 0#
obsNum = 1#
# main loop#
# i is for rows#
# j is for columns#
# #
for (i in 1:dim(subscans)[1]){#
  # there should be a better way to denote the columns below#
  # but manual indexing is the first thing I got to work (and it does work)#
  # for keeping track of which scan it is, within the block#
  if (subscans$Scan.time[i] == "0min"){#
    scanNum = 1#
  } else if (subscans$Scan.time[i] == "10min"){#
    scanNum = 2#
  } else if (subscans$Scan.time[i] == "20min"){#
    scanNum = 3#
  } else if (subscans$Scan.time[i] == "30min"){#
    scanNum = 4#
  }  #
  # for keeping track of which block it is, within the day#
  if ((scanNum == 1) && (i>1)){#
    if (subscans$date[i] == subscans$date[i-1]){#
      obsNum = obsNum + 1#
    } else obsNum = 1#
  }#
  # now the part where we put all this together into a single row#
  for (j in 9:27){#
    if (subscans[i,j] != 'OOS'){#
      MLMformat = rbind(MLMformat, data.frame(date=subscans$date[i],#
                                     observationNumber=obsNum, #
                                     scanNumber=scanNum, #
                                     chimp=colnames(subscans)[j], #
                                     behaviour=subscans[i,j]#
                                     ))#
    }      #
  }    #
}
dim(MLMformat)
head(MLMformat)
levels(chimp)
levels(MLMformat$chimp)
levels(MLMformat$behaviour)
which(MLMformat$behaviour == "")
which(MLMformat$behaviour == " ")
which(MLMformat$behaviour == "GR")
which(MLMformat$behaviour == "Kindia")
which(MLMformat$behaviour == "R ")
which(MLMformat$behaviour == "RG")
which(MLMformat$behaviour == "Lyndsey")
which(MLMformat$behaviour == "0")
which(MLMformat$behaviour == "O")
which(MLMformat$behaviour == "G&R")
which(MLMformat$behaviour == "Paul")
which(MLMformat$behaviour == "RE?")
which(MLMformat$behaviour == "EA*")
which(MLMformat$behaviour == "Lianne")
which(MLMformat$behaviour == "AE")
which(MLMformat$behaviour == "Liberius")
which(MLMformat$behaviour == "Louis")
which(MLMformat$behaviour == "Kilimi")
which(MLMformat$behaviour == "Edith")
which(MLMformat$behaviour == "Frek")
which(MLMformat$behaviour == "Cindy")
which(MLMformat$behaviour == "Qafzeh")
which(MLMformat$behaviour == "David")
which(MLMformat$behaviour == "Lucy")
which(MLMformat$behaviour == "Emma")
which(MLMformat$behaviour == "ES")
which(MLMformat$behaviour == "Eva")
which(MLMformat$behaviour == "R+G")
which(MLMformat$behaviour == "Sofie")
which(MLMformat$behaviour == "RE ")
which(MLMformat$behaviour == "Rene")
which(MLMformat$behaviour == "Heleen")
which(MLMformat$behaviour == "Pearl")
sheets = list.files(pattern="*.csv")
sheets
behav_dat = NULL
behav_dat
i=1#
  temp_dat = NULL#
  temp_dat = read.csv(sheets[i], skip=1, header=TRUE)#
  dmtd = dim(temp_dat) # this is real useful
temp_dat
fill out chimp, day, start time#
  temp_dat$Chimp = temp_dat$Chimp[1]#
  temp_dat$Day = temp_dat$Day[1] # this may need to be further processed into a datetime object#
  temp_dat$Start.time = temp_dat$Start.time[1]#
  # append total length as new column and adjust final row, Time#
  # !!! this needs to be done with Date's, not numerics, otherwise the times will be wrong#
  # so the data needs to be properly standardized#
  # currently this works for Lucy 07-10 data#
  ## once Lucy 07-10 has been modified by dividing time by 60#
  temp_dat$total.length = strptime(substring(temp_dat$Time[dmtd[1]]#
                                               ,7), format='%M')#
  # same for the above guy, it needs to be a certain length string-phrase to exclude#
  # (but the numeric aspect works... for now)#
  temp_dat$Time = strptime(levels(temp_dat$Time)[temp_dat$Time],format="%H:%M:%S")#
  #temp_dat$Time = as.numeric(levels(temp_dat$Time))[temp_dat$Time] # obsolete#
  temp_dat$Time[dmtd[1]]=temp_dat$total.length[1] # may need later adjusts#
  # code time differences for all behaviors (col D)#
  for(j in 1 : dim(temp_dat)[1]-1){#
    temp_dat$behav.length[j] = difftime(temp_dat$Time[j+1],temp_dat$Time[j],units="secs")#
    # the last row has the wrong value#
  }#
  # accounting for all the state behaviors#
  temp_dat$time.Forag = sum(temp_dat$behav.length[temp_dat$Fo == 'x'])#
  temp_dat$time.RestGroom = sum(temp_dat$behav.length[temp_dat$Re.Gr == 'x'])#
  temp_dat$time.Travel = sum(temp_dat$behav.length[temp_dat$Tr == 'x'])#
  temp_dat$time.Forag = sum(temp_dat$behav.length[temp_dat$Fo == 'x'])#
  temp_dat$time.Play = sum(temp_dat$behav.length[temp_dat$Pl == 'x'])#
  temp_dat$time.Di = sum(temp_dat$behav.length[temp_dat$Di == 'x'])#
  # AlloGrooming and Aggression are handled a little differently#
  temp_dat$time.AlloGr.give = sum(temp_dat$behav.length[temp_dat$AG == 'give'])#
  temp_dat$time.AlloGr.receive = sum(temp_dat$behav.length[temp_dat$AG == 'receive'])#
  temp_dat$time.AlloGr.mutual = sum(temp_dat$behav.length[temp_dat$AG == 'mutual'])#
  temp_dat$time.AlloGr.total = temp_dat$time.AlloGr.give+temp_dat$time.AlloGr.receive+temp_dat$time.AlloGr.mutual#
  temp_dat$time.Aggress.give = sum(temp_dat$behav.length[temp_dat$Ag == 'give'])#
  temp_dat$time.Aggress.receive = sum(temp_dat$behav.length[temp_dat$Ag == 'receive'])#
  temp_dat$time.Aggress.mutual = sum(temp_dat$behav.length[temp_dat$Ag == 'mutual'])#
  temp_dat$time.Aggress.total = colSums(rbind(temp_dat$time.Aggress.give,temp_dat$time.Aggress.receive,#
                                              temp_dat$time.Aggress.mutual))#
  #summing these guys when they're full of NAs is a problem#
  # OoS totaling#
  ### TODO does not papear ot be working#
  if ('x' %in% temp_dat$OS){#
    temp_dat$any.OS = 'Y'#
    temp_dat$total.OS = sum(temp_dat$behav.length[temp_dat$OS=='x'])#
  } else {#
    temp_dat$any.OS = 'N'#
    temp_dat$total.OS = NA    #
  }#
  # where does chimp spend the longest time?  #
  areaTotals = aggregate(temp_dat$behav.length, list(temp_dat$Pod), sum)#
  areaTotals = areaTotals[areaTotals$Group.1 != '',]#
  if ('1' %in% areaTotals$Group.1){#
    temp_dat$time.pod1 = areaTotals$x[areaTotals$Group.1 == '1']    #
  } else {#
    temp_dat$time.pod1=NA#
  }#
  if ('2' %in% areaTotals$Group.1){#
    temp_dat$time.pod2 = areaTotals$x[areaTotals$Group.1 == '2']    #
  } else {#
    temp_dat$time.pod2=NA#
  }#
  if ('3' %in% areaTotals$Group.1){#
    temp_dat$time.pod3 = areaTotals$x[areaTotals$Group.1 == '3']    #
  } else {#
    temp_dat$time.pod3=NA#
  }#
  if ('Outside' %in% areaTotals$Group.1){#
    temp_dat$time.out = areaTotals$x[areaTotals$Group.1 == 'Outside']    #
  } else {#
    temp_dat$time.out=NA#
  }#
  # Aggression tabulating#
  if ('x' %in% temp_dat$Ag){#
    temp_dat$any.Ag = 'Y'#
  } else {#
    temp_dat$any.Ag = 'N'#
  }#
  # for the extended Lucy example, this reliead on col Q#
  # but O and P should function exactly the same#
  # Time spent (at all) _near_ others (Q)#
  temp_dat$total.near.others = sum(temp_dat$behav.length[temp_dat$X.Near.others.!=''])#
  #table(temp_dat$X.Near.others.)#
  dyad_list = aggregate(temp_dat$behav.length,by=list(temp_dat$X.Near.others.), FUN=sum)#
  indx = dim(dyad_list)[1]>1#
  temp_dat$most.near =  ifelse(indx,#
          as.character(dyad_list[2,1]),#
         NA)#
  # Time spent sitting with conspecifics#
  temp_dat$total.with.others = sum(temp_dat$behav.length[temp_dat$Sitting.with.conspecific!=''])#
  dyad_list = aggregate(temp_dat$behav.length,by=list(temp_dat$Sitting.with.conspecific.), FUN=sum)#
  indx = dim(dyad_list)[1]>1#
  temp_dat$most.sit.with =  ifelse(indx,#
                               as.character(dyad_list[2,1]),#
                               NA)#
  # Time(s) spent grooming with conspecific#
  temp_dat$total.groom.others = sum(temp_dat$behav.length[temp_dat$Grooming.with.conspecific.!=''])#
  dyad_list = aggregate(temp_dat$behav.length,by=list(temp_dat$Grooming.with.conspecific.), FUN=sum)#
  indx = dim(dyad_list)[1]>1#
  temp_dat$most.groom.with =  ifelse(indx,#
                                   as.character(dyad_list[2,1]),#
                                   NA)#
  ## Emotion - column R onwards#
  temp_dat$total.emotion.events = sum(temp_dat$Full.Display..hoots.only..or.fight.!='')#
  # filter_dat is a new df which is expanded and fit with room for current and previous events:#
  filter_dat <- NULL#
  # identifying rows with emotional events (R complete) *or* reconciliation behav.s#
  # and recording previous states where relevant#
  for (j in 2:dmtd[1]){#
    if ((temp_dat$Full.Display..hoots.only..or.fight.[j] != '') |#
     	is.na(temp_dat$Full.Display..hoots.only..or.fight.[j]) |    #
        (temp_dat$Does.focal.show.consolation.behaviour.after.a.fight.between.conspecifics.[j] != '' &#
         !is.na(temp_dat$Does.focal.show.consolation.behaviour.after.a.fight.between.conspecifics.[j]) #
        ) | #
        (temp_dat$Name.of.conspecific.s..fought.with[j] != '' &  #
         !is.na(temp_dat$Name.of.conspecific.s..fought.with[j]))#
       ){#
      filter_dat = rbind(filter_dat,cbind(temp_dat[j,],temp_dat[j-1,]))#
    }#
  }#
### below is incomplete and needs to be tailored to the preferred directory/spreadsheet setup#
#for (i in 1:length(sheets)){#
#  process_sheet(i)  # fill in later#
#}#
#temp_dat = read.csv(sheets[i], skip=1, header=TRUE)#
#temp_dat$length = as.numeric(substring(temp_dat$Time[dim(temp_dat)[1]],7))#
setwd('..')
temp_dat
sheets
i=2#
  temp_dat = NULL#
  temp_dat = read.csv(sheets[i], skip=2, header=TRUE)
i=2#
  temp_dat = NULL#
  temp_dat = read.csv(sheets[i], skip=, header=TRUE)
i=2#
  temp_dat = NULL#
  temp_dat = read.csv(sheets[i], skip=1, header=TRUE)
dmtd
temp_dat
i=1#
  temp_dat = NULL#
  temp_dat = read.csv(sheets[i], skip=1, header=TRUE)#
  dmtd = dim(temp_dat) # this is real useful#
  # fill out chimp, day, start time#
  temp_dat$Chimp = temp_dat$Chimp[1]#
  temp_dat$Day = temp_dat$Day[1] # this may need to be further processed into a datetime object#
  temp_dat$Start.time = temp_dat$Start.time[1]#
  # append total length as new column and adjust final row, Time#
  # !!! this needs to be done with Date's, not numerics, otherwise the times will be wrong#
  # so the data needs to be properly standardized#
  # currently this works for Lucy 07-10 data#
  ## once Lucy 07-10 has been modified by dividing time by 60#
  temp_dat$total.length = strptime(substring(temp_dat$Time[dmtd[1]]#
                                               ,7), format='%M')#
  # same for the above guy, it needs to be a certain length string-phrase to exclude#
  # (but the numeric aspect works... for now)#
  temp_dat$Time = strptime(levels(temp_dat$Time)[temp_dat$Time],format="%H:%M:%S")#
  #temp_dat$Time = as.numeric(levels(temp_dat$Time))[temp_dat$Time] # obsolete#
  temp_dat$Time[dmtd[1]]=temp_dat$total.length[1] # may need later adjusts#
  # code time differences for all behaviors (col D)#
  for(j in 1 : dim(temp_dat)[1]-1){#
    temp_dat$behav.length[j] = difftime(temp_dat$Time[j+1],temp_dat$Time[j],units="secs")#
    # the last row has the wrong value#
  }#
  # accounting for all the state behaviors#
  temp_dat$time.Forag = sum(temp_dat$behav.length[temp_dat$Fo == 'x'])#
  temp_dat$time.RestGroom = sum(temp_dat$behav.length[temp_dat$Re.Gr == 'x'])#
  temp_dat$time.Travel = sum(temp_dat$behav.length[temp_dat$Tr == 'x'])#
  temp_dat$time.Forag = sum(temp_dat$behav.length[temp_dat$Fo == 'x'])#
  temp_dat$time.Play = sum(temp_dat$behav.length[temp_dat$Pl == 'x'])#
  temp_dat$time.Di = sum(temp_dat$behav.length[temp_dat$Di == 'x'])#
  # AlloGrooming and Aggression are handled a little differently#
  temp_dat$time.AlloGr.give = sum(temp_dat$behav.length[temp_dat$AG == 'give'])#
  temp_dat$time.AlloGr.receive = sum(temp_dat$behav.length[temp_dat$AG == 'receive'])#
  temp_dat$time.AlloGr.mutual = sum(temp_dat$behav.length[temp_dat$AG == 'mutual'])#
  temp_dat$time.AlloGr.total = temp_dat$time.AlloGr.give+temp_dat$time.AlloGr.receive+temp_dat$time.AlloGr.mutual#
  temp_dat$time.Aggress.give = sum(temp_dat$behav.length[temp_dat$Ag == 'give'])#
  temp_dat$time.Aggress.receive = sum(temp_dat$behav.length[temp_dat$Ag == 'receive'])#
  temp_dat$time.Aggress.mutual = sum(temp_dat$behav.length[temp_dat$Ag == 'mutual'])#
  temp_dat$time.Aggress.total = colSums(rbind(temp_dat$time.Aggress.give,temp_dat$time.Aggress.receive,#
                                              temp_dat$time.Aggress.mutual))#
  #summing these guys when they're full of NAs is a problem#
  # OoS totaling#
  ### TODO does not papear ot be working#
  if ('x' %in% temp_dat$OS){#
    temp_dat$any.OS = 'Y'#
    temp_dat$total.OS = sum(temp_dat$behav.length[temp_dat$OS=='x'])#
  } else {#
    temp_dat$any.OS = 'N'#
    temp_dat$total.OS = NA    #
  }#
  # where does chimp spend the longest time?  #
  areaTotals = aggregate(temp_dat$behav.length, list(temp_dat$Pod), sum)#
  areaTotals = areaTotals[areaTotals$Group.1 != '',]#
  if ('1' %in% areaTotals$Group.1){#
    temp_dat$time.pod1 = areaTotals$x[areaTotals$Group.1 == '1']    #
  } else {#
    temp_dat$time.pod1=NA#
  }#
  if ('2' %in% areaTotals$Group.1){#
    temp_dat$time.pod2 = areaTotals$x[areaTotals$Group.1 == '2']    #
  } else {#
    temp_dat$time.pod2=NA#
  }#
  if ('3' %in% areaTotals$Group.1){#
    temp_dat$time.pod3 = areaTotals$x[areaTotals$Group.1 == '3']    #
  } else {#
    temp_dat$time.pod3=NA#
  }#
  if ('Outside' %in% areaTotals$Group.1){#
    temp_dat$time.out = areaTotals$x[areaTotals$Group.1 == 'Outside']    #
  } else {#
    temp_dat$time.out=NA#
  }#
  # Aggression tabulating#
  if ('x' %in% temp_dat$Ag){#
    temp_dat$any.Ag = 'Y'#
  } else {#
    temp_dat$any.Ag = 'N'#
  }#
  # for the extended Lucy example, this reliead on col Q#
  # but O and P should function exactly the same#
  # Time spent (at all) _near_ others (Q)#
  temp_dat$total.near.others = sum(temp_dat$behav.length[temp_dat$X.Near.others.!=''])#
  #table(temp_dat$X.Near.others.)#
  dyad_list = aggregate(temp_dat$behav.length,by=list(temp_dat$X.Near.others.), FUN=sum)#
  indx = dim(dyad_list)[1]>1#
  temp_dat$most.near =  ifelse(indx,#
          as.character(dyad_list[2,1]),#
         NA)#
  # Time spent sitting with conspecifics#
  temp_dat$total.with.others = sum(temp_dat$behav.length[temp_dat$Sitting.with.conspecific!=''])#
  dyad_list = aggregate(temp_dat$behav.length,by=list(temp_dat$Sitting.with.conspecific.), FUN=sum)#
  indx = dim(dyad_list)[1]>1#
  temp_dat$most.sit.with =  ifelse(indx,#
                               as.character(dyad_list[2,1]),#
                               NA)#
  # Time(s) spent grooming with conspecific#
  temp_dat$total.groom.others = sum(temp_dat$behav.length[temp_dat$Grooming.with.conspecific.!=''])#
  dyad_list = aggregate(temp_dat$behav.length,by=list(temp_dat$Grooming.with.conspecific.), FUN=sum)#
  indx = dim(dyad_list)[1]>1#
  temp_dat$most.groom.with =  ifelse(indx,#
                                   as.character(dyad_list[2,1]),#
                                   NA)#
  ## Emotion - column R onwards#
  temp_dat$total.emotion.events = sum(temp_dat$Full.Display..hoots.only..or.fight.!='')#
  # filter_dat is a new df which is expanded and fit with room for current and previous events:#
  filter_dat <- NULL#
  # identifying rows with emotional events (R complete) *or* reconciliation behav.s#
  # and recording previous states where relevant#
  for (j in 2:dmtd[1]){#
    if ((temp_dat$Full.Display..hoots.only..or.fight.[j] != '') |#
     	is.na(temp_dat$Full.Display..hoots.only..or.fight.[j]) |    #
        (temp_dat$Does.focal.show.consolation.behaviour.after.a.fight.between.conspecifics.[j] != '' &#
         !is.na(temp_dat$Does.focal.show.consolation.behaviour.after.a.fight.between.conspecifics.[j]) #
        ) | #
        (temp_dat$Name.of.conspecific.s..fought.with[j] != '' &  #
         !is.na(temp_dat$Name.of.conspecific.s..fought.with[j]))#
       ){#
      filter_dat = rbind(filter_dat,cbind(temp_dat[j,],temp_dat[j-1,]))#
    }#
  }#
### below is incomplete and needs to be tailored to the preferred directory/spreadsheet setup#
#for (i in 1:length(sheets)){#
#  process_sheet(i)  # fill in later#
#}#
#temp_dat = read.csv(sheets[i], skip=1, header=TRUE)#
#temp_dat$length = as.numeric(substring(temp_dat$Time[dim(temp_dat)[1]],7))#
setwd('..')
i=2#
  temp_dat2 = NULL#
  temp_dat2 = read.csv(sheets[i], skip=1, header=TRUE)
i=2#
  temp_dat2 = NULL#
  temp_dat2 = read.csv(sheets[i], skip=2, header=TRUE)
head(temp_dat)
temp_dat
i=1#
  temp_dat = NULL#
  temp_dat = read.csv(sheets[i], skip=1, header=TRUE)#
  dmtd = dim(temp_dat) # this is real useful
head(temp_dat)
i=1#
  temp_dat = NULL#
  temp_dat = read.csv(sheets[i], skip=1, header=TRUE)#
  dmtd = dim(temp_dat) # this is real useful
head(temp_dat)
i=2#
  temp_dat2 = NULL#
  temp_dat2 = read.csv(sheets[i], skip=1, header=TRUE)
head(temp_dat2)
i=3#
  temp_dat = NULL#
  temp_dat = read.csv(sheets[i], skip=1, header=TRUE)
head(temp_dat)
names(temp_dat)
temp_dat$time.Aggress.mutual
fill out chimp, day, start time#
  temp_dat$Chimp = temp_dat$Chimp[1]#
  temp_dat$Day = temp_dat$Day[1] # this may need to be further processed into a datetime object#
  temp_dat$Start.time = temp_dat$Start.time[1]#
  # append total length as new column and adjust final row, Time#
  # !!! this needs to be done with Date's, not numerics, otherwise the times will be wrong#
  # so the data needs to be properly standardized#
  # currently this works for Lucy 07-10 data#
  ## once Lucy 07-10 has been modified by dividing time by 60#
  temp_dat$total.length = strptime(substring(temp_dat$Time[dmtd[1]]#
                                               ,7), format='%M')#
  # same for the above guy, it needs to be a certain length string-phrase to exclude#
  # (but the numeric aspect works... for now)#
  temp_dat$Time = strptime(levels(temp_dat$Time)[temp_dat$Time],format="%H:%M:%S")#
  #temp_dat$Time = as.numeric(levels(temp_dat$Time))[temp_dat$Time] # obsolete#
  temp_dat$Time[dmtd[1]]=temp_dat$total.length[1] # may need later adjusts#
  # code time differences for all behaviors (col D)#
  for(j in 1 : dim(temp_dat)[1]-1){#
    temp_dat$behav.length[j] = difftime(temp_dat$Time[j+1],temp_dat$Time[j],units="secs")#
    # the last row has the wrong value#
  }#
  # accounting for all the state behaviors#
  temp_dat$time.Forag = sum(temp_dat$behav.length[temp_dat$Fo == 'x'])#
  temp_dat$time.RestGroom = sum(temp_dat$behav.length[temp_dat$Re.Gr == 'x'])#
  temp_dat$time.Travel = sum(temp_dat$behav.length[temp_dat$Tr == 'x'])#
  temp_dat$time.Forag = sum(temp_dat$behav.length[temp_dat$Fo == 'x'])#
  temp_dat$time.Play = sum(temp_dat$behav.length[temp_dat$Pl == 'x'])#
  temp_dat$time.Di = sum(temp_dat$behav.length[temp_dat$Di == 'x'])#
  # AlloGrooming and Aggression are handled a little differently#
  temp_dat$time.AlloGr.give = sum(temp_dat$behav.length[temp_dat$AG == 'give'])#
  temp_dat$time.AlloGr.receive = sum(temp_dat$behav.length[temp_dat$AG == 'receive'])#
  temp_dat$time.AlloGr.mutual = sum(temp_dat$behav.length[temp_dat$AG == 'mutual'])#
  temp_dat$time.AlloGr.total = temp_dat$time.AlloGr.give+temp_dat$time.AlloGr.receive+temp_dat$time.AlloGr.mutual#
  temp_dat$time.Aggress.give = sum(temp_dat$behav.length[temp_dat$Ag == 'give'])#
  temp_dat$time.Aggress.receive = sum(temp_dat$behav.length[temp_dat$Ag == 'receive'])#
  temp_dat$time.Aggress.mutual = sum(temp_dat$behav.length[temp_dat$Ag == 'mutual'])#
  temp_dat$time.Aggress.total = colSums(rbind(temp_dat$time.Aggress.give,temp_dat$time.Aggress.receive,#
                                              temp_dat$time.Aggress.mutual))#
  #summing these guys when they're full of NAs is a problem#
  # OoS totaling#
  ### TODO does not appear to be working#
  if ('x' %in% temp_dat$OS){#
    temp_dat$any.OS = 'Y'#
    temp_dat$total.OS = sum(temp_dat$behav.length[temp_dat$OS=='x'])#
  } else {#
    temp_dat$any.OS = 'N'#
    temp_dat$total.OS = NA    #
  }#
  # where does chimp spend the longest time?  #
  areaTotals = aggregate(temp_dat$behav.length, list(temp_dat$Pod), sum)#
  areaTotals = areaTotals[areaTotals$Group.1 != '',]#
  if ('1' %in% areaTotals$Group.1){#
    temp_dat$time.pod1 = areaTotals$x[areaTotals$Group.1 == '1']    #
  } else {#
    temp_dat$time.pod1=NA#
  }#
  if ('2' %in% areaTotals$Group.1){#
    temp_dat$time.pod2 = areaTotals$x[areaTotals$Group.1 == '2']    #
  } else {#
    temp_dat$time.pod2=NA#
  }#
  if ('3' %in% areaTotals$Group.1){#
    temp_dat$time.pod3 = areaTotals$x[areaTotals$Group.1 == '3']    #
  } else {#
    temp_dat$time.pod3=NA#
  }#
  if ('Outside' %in% areaTotals$Group.1){#
    temp_dat$time.out = areaTotals$x[areaTotals$Group.1 == 'Outside']    #
  } else {#
    temp_dat$time.out=NA#
  }#
  # Aggression tabulating#
  if ('x' %in% temp_dat$Ag){#
    temp_dat$any.Ag = 'Y'#
  } else {#
    temp_dat$any.Ag = 'N'#
  }#
  # for the extended Lucy example, this relied on col Q#
  # but O and P should function exactly the same#
  # Time spent (at all) _near_ others (Q)#
  temp_dat$total.near.others = sum(temp_dat$behav.length[temp_dat$X.Near.others.!=''])#
  #table(temp_dat$X.Near.others.)#
  dyad_list = aggregate(temp_dat$behav.length,by=list(temp_dat$X.Near.others.), FUN=sum)#
  indx = dim(dyad_list)[1]>1#
  temp_dat$most.near =  ifelse(indx,#
          as.character(dyad_list[2,1]),#
         NA)#
  # Time spent sitting with conspecifics#
  temp_dat$total.with.others = sum(temp_dat$behav.length[temp_dat$Sitting.with.conspecific!=''])#
  dyad_list = aggregate(temp_dat$behav.length,by=list(temp_dat$Sitting.with.conspecific.), FUN=sum)#
  indx = dim(dyad_list)[1]>1#
  temp_dat$most.sit.with =  ifelse(indx,#
                               as.character(dyad_list[2,1]),#
                               NA)#
  # Time(s) spent grooming with conspecific#
  temp_dat$total.groom.others = sum(temp_dat$behav.length[temp_dat$Grooming.with.conspecific.!=''])#
  dyad_list = aggregate(temp_dat$behav.length,by=list(temp_dat$Grooming.with.conspecific.), FUN=sum)#
  indx = dim(dyad_list)[1]>1#
  temp_dat$most.groom.with =  ifelse(indx,#
                                   as.character(dyad_list[2,1]),#
                                   NA)#
  ## Emotion - column R onwards#
  temp_dat$total.emotion.events = sum(temp_dat$Full.Display..hoots.only..or.fight.!='')#
  # filter_dat is a new df which is expanded and fit with room for current and previous events:#
  filter_dat <- NULL#
  # identifying rows with emotional events (R complete) *or* reconciliation behav.s#
  # and recording previous states where relevant#
  for (j in 2:dmtd[1]){#
    if ((temp_dat$Full.Display..hoots.only..or.fight.[j] != '') |#
     	is.na(temp_dat$Full.Display..hoots.only..or.fight.[j]) |    #
        (temp_dat$Does.focal.show.consolation.behaviour.after.a.fight.between.conspecifics.[j] != '' &#
         !is.na(temp_dat$Does.focal.show.consolation.behaviour.after.a.fight.between.conspecifics.[j]) #
        ) | #
        (temp_dat$Name.of.conspecific.s..fought.with[j] != '' &  #
         !is.na(temp_dat$Name.of.conspecific.s..fought.with[j]))#
       ){#
      filter_dat = rbind(filter_dat,cbind(temp_dat[j,],temp_dat[j-1,]))#
    }#
  }#
### below is incomplete and needs to be tailored to the preferred directory/spreadsheet setup#
#for (i in 1:length(sheets)){#
#  process_sheet(i)  # fill in later#
#}#
#temp_dat = read.csv(sheets[i], skip=1, header=TRUE)#
#temp_dat$length = as.numeric(substring(temp_dat$Time[dim(temp_dat)[1]],7))#
setwd('..')
temp_dat$time.Aggress.mutual
temp_dat$time.out
head(temp_dat)
temp_dat$time.pod3
temp_dat
i=1#
  temp_dat = NULL#
  temp_dat = read.csv(sheets[i], skip=1, header=TRUE)
i=1#
  temp_dat = NULL#
  temp_dat = read.csv(sheets[i], skip=1, header=TRUE)
temp_dat
i=1#
  temp_dat = NULL#
  temp_dat = read.csv(sheets[i], skip=1, header=TRUE)
sheets
head(temp_dat)
temp_dat
i=1#
  temp_dat = NULL#
  temp_dat = read.csv(sheets[i], skip=1, header=TRUE)
temp_dat
dmtd = dim(temp_dat) # this is real useful#
  # fill out chimp, day, start time#
  temp_dat$Chimp = temp_dat$Chimp[1]#
  temp_dat$Day = temp_dat$Day[1] # this may need to be further processed into a datetime object#
  temp_dat$Start.time = temp_dat$Start.time[1]#
  # append total length as new column and adjust final row, Time#
  # !!! this needs to be done with Date's, not numerics, otherwise the times will be wrong#
  # so the data needs to be properly standardized#
  # currently this works for Lucy 07-10 data#
  ## once Lucy 07-10 has been modified by dividing time by 60#
  temp_dat$total.length = strptime(substring(temp_dat$Time[dmtd[1]]#
                                               ,7), format='%M')#
  # same for the above guy, it needs to be a certain length string-phrase to exclude#
  # (but the numeric aspect works... for now)#
  temp_dat$Time = strptime(levels(temp_dat$Time)[temp_dat$Time],format="%H:%M:%S")#
  #temp_dat$Time = as.numeric(levels(temp_dat$Time))[temp_dat$Time] # obsolete#
  temp_dat$Time[dmtd[1]]=temp_dat$total.length[1] # may need later adjusts#
  # code time differences for all behaviors (col D)#
  for(j in 1 : dim(temp_dat)[1]-1){#
    temp_dat$behav.length[j] = difftime(temp_dat$Time[j+1],temp_dat$Time[j],units="secs")#
    # the last row has the wrong value#
  }#
  # accounting for all the state behaviors#
  temp_dat$time.Forag = sum(temp_dat$behav.length[temp_dat$Fo == 'x'])#
  temp_dat$time.RestGroom = sum(temp_dat$behav.length[temp_dat$Re.Gr == 'x'])#
  temp_dat$time.Travel = sum(temp_dat$behav.length[temp_dat$Tr == 'x'])#
  temp_dat$time.Forag = sum(temp_dat$behav.length[temp_dat$Fo == 'x'])#
  temp_dat$time.Play = sum(temp_dat$behav.length[temp_dat$Pl == 'x'])#
  temp_dat$time.Di = sum(temp_dat$behav.length[temp_dat$Di == 'x'])#
  # AlloGrooming and Aggression are handled a little differently#
  temp_dat$time.AlloGr.give = sum(temp_dat$behav.length[temp_dat$AG == 'give'])#
  temp_dat$time.AlloGr.receive = sum(temp_dat$behav.length[temp_dat$AG == 'receive'])#
  temp_dat$time.AlloGr.mutual = sum(temp_dat$behav.length[temp_dat$AG == 'mutual'])#
  temp_dat$time.AlloGr.total = temp_dat$time.AlloGr.give+temp_dat$time.AlloGr.receive+temp_dat$time.AlloGr.mutual#
  temp_dat$time.Aggress.give = sum(temp_dat$behav.length[temp_dat$Ag == 'give'])#
  temp_dat$time.Aggress.receive = sum(temp_dat$behav.length[temp_dat$Ag == 'receive'])#
  temp_dat$time.Aggress.mutual = sum(temp_dat$behav.length[temp_dat$Ag == 'mutual'])#
  temp_dat$time.Aggress.total = colSums(rbind(temp_dat$time.Aggress.give,temp_dat$time.Aggress.receive,#
                                              temp_dat$time.Aggress.mutual))#
  #summing these guys when they're full of NAs is a problem#
  # OoS totaling#
  ### TODO does not appear to be working#
  if ('x' %in% temp_dat$OS){#
    temp_dat$any.OS = 'Y'#
    temp_dat$total.OS = sum(temp_dat$behav.length[temp_dat$OS=='x'])#
  } else {#
    temp_dat$any.OS = 'N'#
    temp_dat$total.OS = NA    #
  }#
  # where does chimp spend the longest time?  #
  areaTotals = aggregate(temp_dat$behav.length, list(temp_dat$Pod), sum)#
  areaTotals = areaTotals[areaTotals$Group.1 != '',]#
  if ('1' %in% areaTotals$Group.1){#
    temp_dat$time.pod1 = areaTotals$x[areaTotals$Group.1 == '1']    #
  } else {#
    temp_dat$time.pod1=NA#
  }#
  if ('2' %in% areaTotals$Group.1){#
    temp_dat$time.pod2 = areaTotals$x[areaTotals$Group.1 == '2']    #
  } else {#
    temp_dat$time.pod2=NA#
  }#
  if ('3' %in% areaTotals$Group.1){#
    temp_dat$time.pod3 = areaTotals$x[areaTotals$Group.1 == '3']    #
  } else {#
    temp_dat$time.pod3=NA#
  }#
  if ('Outside' %in% areaTotals$Group.1){#
    temp_dat$time.out = areaTotals$x[areaTotals$Group.1 == 'Outside']    #
  } else {#
    temp_dat$time.out=NA#
  }#
  # Aggression tabulating#
  if ('x' %in% temp_dat$Ag){#
    temp_dat$any.Ag = 'Y'#
  } else {#
    temp_dat$any.Ag = 'N'#
  }#
  # for the extended Lucy example, this relied on col Q#
  # but O and P should function exactly the same#
  # Time spent (at all) _near_ others (Q)#
  temp_dat$total.near.others = sum(temp_dat$behav.length[temp_dat$X.Near.others.!=''])#
  #table(temp_dat$X.Near.others.)#
  dyad_list = aggregate(temp_dat$behav.length,by=list(temp_dat$X.Near.others.), FUN=sum)#
  indx = dim(dyad_list)[1]>1#
  temp_dat$most.near =  ifelse(indx,#
          as.character(dyad_list[2,1]),#
         NA)#
  # Time spent sitting with conspecifics#
  temp_dat$total.with.others = sum(temp_dat$behav.length[temp_dat$Sitting.with.conspecific!=''])#
  dyad_list = aggregate(temp_dat$behav.length,by=list(temp_dat$Sitting.with.conspecific.), FUN=sum)#
  indx = dim(dyad_list)[1]>1#
  temp_dat$most.sit.with =  ifelse(indx,#
                               as.character(dyad_list[2,1]),#
                               NA)#
  # Time(s) spent grooming with conspecific#
  temp_dat$total.groom.others = sum(temp_dat$behav.length[temp_dat$Grooming.with.conspecific.!=''])#
  dyad_list = aggregate(temp_dat$behav.length,by=list(temp_dat$Grooming.with.conspecific.), FUN=sum)#
  indx = dim(dyad_list)[1]>1#
  temp_dat$most.groom.with =  ifelse(indx,#
                                   as.character(dyad_list[2,1]),#
                                   NA)#
  ## Emotion - column R onwards#
  temp_dat$total.emotion.events = sum(temp_dat$Full.Display..hoots.only..or.fight.!='')#
  # filter_dat is a new df which is expanded and fit with room for current and previous events:#
  filter_dat <- NULL#
  # identifying rows with emotional events (R complete) *or* reconciliation behav.s#
  # and recording previous states where relevant#
  for (j in 2:dmtd[1]){#
    if ((temp_dat$Full.Display..hoots.only..or.fight.[j] != '') |#
     	is.na(temp_dat$Full.Display..hoots.only..or.fight.[j]) |    #
        (temp_dat$Does.focal.show.consolation.behaviour.after.a.fight.between.conspecifics.[j] != '' &#
         !is.na(temp_dat$Does.focal.show.consolation.behaviour.after.a.fight.between.conspecifics.[j]) #
        ) | #
        (temp_dat$Name.of.conspecific.s..fought.with[j] != '' &  #
         !is.na(temp_dat$Name.of.conspecific.s..fought.with[j]))#
       ){#
      filter_dat = rbind(filter_dat,cbind(temp_dat[j,],temp_dat[j-1,]))#
    }#
  }#
### below is incomplete and needs to be tailored to the preferred directory/spreadsheet setup#
#for (i in 1:length(sheets)){#
#  process_sheet(i)  # fill in later#
#}#
#temp_dat = read.csv(sheets[i], skip=1, header=TRUE)#
#temp_dat$length = as.numeric(substring(temp_dat$Time[dim(temp_dat)[1]],7))#
setwd('..')
temp_dat
sheets
i=11#
  temp_dat = NULL#
  temp_dat = read.csv(sheets[i], skip=1, header=TRUE)
i=11#
  temp_dat = NULL#
  temp_dat = read.csv(sheets[i], skip=1, header=TRUE)
head(temp_dat)
fill out chimp, day, start time#
  temp_dat$Chimp = temp_dat$Chimp[1]#
  temp_dat$Day = temp_dat$Day[1] # this may need to be further processed into a datetime object#
  temp_dat$Start.time = temp_dat$Start.time[1]#
  # append total length as new column and adjust final row, Time#
  # !!! this needs to be done with Date's, not numerics, otherwise the times will be wrong#
  # so the data needs to be properly standardized#
  # currently this works for Lucy 07-10 data#
  ## once Lucy 07-10 has been modified by dividing time by 60#
  temp_dat$total.length = strptime(substring(temp_dat$Time[dmtd[1]]#
                                               ,7), format='%M')#
  # same for the above guy, it needs to be a certain length string-phrase to exclude#
  # (but the numeric aspect works... for now)#
  temp_dat$Time = strptime(levels(temp_dat$Time)[temp_dat$Time],format="%H:%M:%S")#
  #temp_dat$Time = as.numeric(levels(temp_dat$Time))[temp_dat$Time] # obsolete#
  temp_dat$Time[dmtd[1]]=temp_dat$total.length[1] # may need later adjusts#
  # code time differences for all behaviors (col D)#
  for(j in 1 : dim(temp_dat)[1]-1){#
    temp_dat$behav.length[j] = difftime(temp_dat$Time[j+1],temp_dat$Time[j],units="secs")#
    # the last row has the wrong value#
  }#
  # accounting for all the state behaviors#
  temp_dat$time.Forag = sum(temp_dat$behav.length[temp_dat$Fo == 'x'])#
  temp_dat$time.RestGroom = sum(temp_dat$behav.length[temp_dat$Re.Gr == 'x'])#
  temp_dat$time.Travel = sum(temp_dat$behav.length[temp_dat$Tr == 'x'])#
  temp_dat$time.Forag = sum(temp_dat$behav.length[temp_dat$Fo == 'x'])#
  temp_dat$time.Play = sum(temp_dat$behav.length[temp_dat$Pl == 'x'])#
  temp_dat$time.Di = sum(temp_dat$behav.length[temp_dat$Di == 'x'])#
  # AlloGrooming and Aggression are handled a little differently#
  temp_dat$time.AlloGr.give = sum(temp_dat$behav.length[temp_dat$AG == 'give'])#
  temp_dat$time.AlloGr.receive = sum(temp_dat$behav.length[temp_dat$AG == 'receive'])#
  temp_dat$time.AlloGr.mutual = sum(temp_dat$behav.length[temp_dat$AG == 'mutual'])#
  temp_dat$time.AlloGr.total = temp_dat$time.AlloGr.give+temp_dat$time.AlloGr.receive+temp_dat$time.AlloGr.mutual#
  temp_dat$time.Aggress.give = sum(temp_dat$behav.length[temp_dat$Ag == 'give'])#
  temp_dat$time.Aggress.receive = sum(temp_dat$behav.length[temp_dat$Ag == 'receive'])#
  temp_dat$time.Aggress.mutual = sum(temp_dat$behav.length[temp_dat$Ag == 'mutual'])#
  temp_dat$time.Aggress.total = colSums(rbind(temp_dat$time.Aggress.give,temp_dat$time.Aggress.receive,#
                                              temp_dat$time.Aggress.mutual))#
  #summing these guys when they're full of NAs is a problem#
  # OoS totaling#
  ### TODO does not appear to be working#
  if ('x' %in% temp_dat$OS){#
    temp_dat$any.OS = 'Y'#
    temp_dat$total.OS = sum(temp_dat$behav.length[temp_dat$OS=='x'])#
  } else {#
    temp_dat$any.OS = 'N'#
    temp_dat$total.OS = NA    #
  }#
  # where does chimp spend the longest time?  #
  areaTotals = aggregate(temp_dat$behav.length, list(temp_dat$Pod), sum)#
  areaTotals = areaTotals[areaTotals$Group.1 != '',]#
  if ('1' %in% areaTotals$Group.1){#
    temp_dat$time.pod1 = areaTotals$x[areaTotals$Group.1 == '1']    #
  } else {#
    temp_dat$time.pod1=NA#
  }#
  if ('2' %in% areaTotals$Group.1){#
    temp_dat$time.pod2 = areaTotals$x[areaTotals$Group.1 == '2']    #
  } else {#
    temp_dat$time.pod2=NA#
  }#
  if ('3' %in% areaTotals$Group.1){#
    temp_dat$time.pod3 = areaTotals$x[areaTotals$Group.1 == '3']    #
  } else {#
    temp_dat$time.pod3=NA#
  }#
  if ('Outside' %in% areaTotals$Group.1){#
    temp_dat$time.out = areaTotals$x[areaTotals$Group.1 == 'Outside']    #
  } else {#
    temp_dat$time.out=NA#
  }#
  # Aggression tabulating#
  if ('x' %in% temp_dat$Ag){#
    temp_dat$any.Ag = 'Y'#
  } else {#
    temp_dat$any.Ag = 'N'#
  }#
  # for the extended Lucy example, this relied on col Q#
  # but O and P should function exactly the same#
  # Time spent (at all) _near_ others (Q)#
  temp_dat$total.near.others = sum(temp_dat$behav.length[temp_dat$X.Near.others.!=''])#
  #table(temp_dat$X.Near.others.)#
  dyad_list = aggregate(temp_dat$behav.length,by=list(temp_dat$X.Near.others.), FUN=sum)#
  indx = dim(dyad_list)[1]>1#
  temp_dat$most.near =  ifelse(indx,#
          as.character(dyad_list[2,1]),#
         NA)#
  # Time spent sitting with conspecifics#
  temp_dat$total.with.others = sum(temp_dat$behav.length[temp_dat$Sitting.with.conspecific!=''])#
  dyad_list = aggregate(temp_dat$behav.length,by=list(temp_dat$Sitting.with.conspecific.), FUN=sum)#
  indx = dim(dyad_list)[1]>1#
  temp_dat$most.sit.with =  ifelse(indx,#
                               as.character(dyad_list[2,1]),#
                               NA)#
  # Time(s) spent grooming with conspecific#
  temp_dat$total.groom.others = sum(temp_dat$behav.length[temp_dat$Grooming.with.conspecific.!=''])#
  dyad_list = aggregate(temp_dat$behav.length,by=list(temp_dat$Grooming.with.conspecific.), FUN=sum)#
  indx = dim(dyad_list)[1]>1#
  temp_dat$most.groom.with =  ifelse(indx,#
                                   as.character(dyad_list[2,1]),#
                                   NA)#
  ## Emotion - column R onwards#
  temp_dat$total.emotion.events = sum(temp_dat$Full.Display..hoots.only..or.fight.!='')#
  # filter_dat is a new df which is expanded and fit with room for current and previous events:#
  filter_dat <- NULL#
  # identifying rows with emotional events (R complete) *or* reconciliation behav.s#
  # and recording previous states where relevant#
  for (j in 2:dmtd[1]){#
    if ((temp_dat$Full.Display..hoots.only..or.fight.[j] != '') |#
     	is.na(temp_dat$Full.Display..hoots.only..or.fight.[j]) |    #
        (temp_dat$Does.focal.show.consolation.behaviour.after.a.fight.between.conspecifics.[j] != '' &#
         !is.na(temp_dat$Does.focal.show.consolation.behaviour.after.a.fight.between.conspecifics.[j]) #
        ) | #
        (temp_dat$Name.of.conspecific.s..fought.with[j] != '' &  #
         !is.na(temp_dat$Name.of.conspecific.s..fought.with[j]))#
       ){#
      filter_dat = rbind(filter_dat,cbind(temp_dat[j,],temp_dat[j-1,]))#
    }#
  }#
### below is incomplete and needs to be tailored to the preferred directory/spreadsheet setup#
#for (i in 1:length(sheets)){#
#  process_sheet(i)  # fill in later#
#}#
#temp_dat = read.csv(sheets[i], skip=1, header=TRUE)#
#temp_dat$length = as.numeric(substring(temp_dat$Time[dim(temp_dat)[1]],7))#
setwd('..')
temp_dat
i=11#
  temp_dat = NULL#
  temp_dat = read.csv(sheets[i], skip=1, header=TRUE)
i=11#
  temp_dat = NULL#
  temp_dat = read.csv(sheets[i], skip=1, header=TRUE)
fill out chimp, day, start time#
  temp_dat$Chimp = temp_dat$Chimp[1]#
  temp_dat$Day = temp_dat$Day[1] # this may need to be further processed into a datetime object#
  temp_dat$Start.time = temp_dat$Start.time[1]#
  # append total length as new column and adjust final row, Time#
  # !!! this needs to be done with Date's, not numerics, otherwise the times will be wrong#
  # so the data needs to be properly standardized#
  # currently this works for Lucy 07-10 data#
  ## once Lucy 07-10 has been modified by dividing time by 60#
  temp_dat$total.length = strptime(substring(temp_dat$Time[dmtd[1]]#
                                               ,7), format='%M')#
  # same for the above guy, it needs to be a certain length string-phrase to exclude#
  # (but the numeric aspect works... for now)#
  temp_dat$Time = strptime(levels(temp_dat$Time)[temp_dat$Time],format="%H:%M:%S")#
  #temp_dat$Time = as.numeric(levels(temp_dat$Time))[temp_dat$Time] # obsolete#
  temp_dat$Time[dmtd[1]]=temp_dat$total.length[1] # may need later adjusts#
  # code time differences for all behaviors (col D)#
  for(j in 1 : dim(temp_dat)[1]-1){#
    temp_dat$behav.length[j] = difftime(temp_dat$Time[j+1],temp_dat$Time[j],units="secs")#
    # the last row has the wrong value#
  }#
  # accounting for all the state behaviors#
  temp_dat$time.Forag = sum(temp_dat$behav.length[temp_dat$Fo == 'x'])#
  temp_dat$time.RestGroom = sum(temp_dat$behav.length[temp_dat$Re.Gr == 'x'])#
  temp_dat$time.Travel = sum(temp_dat$behav.length[temp_dat$Tr == 'x'])#
  temp_dat$time.Forag = sum(temp_dat$behav.length[temp_dat$Fo == 'x'])#
  temp_dat$time.Play = sum(temp_dat$behav.length[temp_dat$Pl == 'x'])#
  temp_dat$time.Di = sum(temp_dat$behav.length[temp_dat$Di == 'x'])#
  # AlloGrooming and Aggression are handled a little differently#
  temp_dat$time.AlloGr.give = sum(temp_dat$behav.length[temp_dat$AG == 'give'])#
  temp_dat$time.AlloGr.receive = sum(temp_dat$behav.length[temp_dat$AG == 'receive'])#
  temp_dat$time.AlloGr.mutual = sum(temp_dat$behav.length[temp_dat$AG == 'mutual'])#
  temp_dat$time.AlloGr.total = temp_dat$time.AlloGr.give+temp_dat$time.AlloGr.receive+temp_dat$time.AlloGr.mutual#
  temp_dat$time.Aggress.give = sum(temp_dat$behav.length[temp_dat$Ag == 'give'])#
  temp_dat$time.Aggress.receive = sum(temp_dat$behav.length[temp_dat$Ag == 'receive'])#
  temp_dat$time.Aggress.mutual = sum(temp_dat$behav.length[temp_dat$Ag == 'mutual'])#
  temp_dat$time.Aggress.total = colSums(rbind(temp_dat$time.Aggress.give,temp_dat$time.Aggress.receive,#
                                              temp_dat$time.Aggress.mutual))#
  #summing these guys when they're full of NAs is a problem#
  # OoS totaling#
  ### TODO does not appear to be working#
  if ('x' %in% temp_dat$OS){#
    temp_dat$any.OS = 'Y'#
    temp_dat$total.OS = sum(temp_dat$behav.length[temp_dat$OS=='x'])#
  } else {#
    temp_dat$any.OS = 'N'#
    temp_dat$total.OS = NA    #
  }#
  # where does chimp spend the longest time?  #
  areaTotals = aggregate(temp_dat$behav.length, list(temp_dat$Pod), sum)#
  areaTotals = areaTotals[areaTotals$Group.1 != '',]#
  if ('1' %in% areaTotals$Group.1){#
    temp_dat$time.pod1 = areaTotals$x[areaTotals$Group.1 == '1']    #
  } else {#
    temp_dat$time.pod1=NA#
  }#
  if ('2' %in% areaTotals$Group.1){#
    temp_dat$time.pod2 = areaTotals$x[areaTotals$Group.1 == '2']    #
  } else {#
    temp_dat$time.pod2=NA#
  }#
  if ('3' %in% areaTotals$Group.1){#
    temp_dat$time.pod3 = areaTotals$x[areaTotals$Group.1 == '3']    #
  } else {#
    temp_dat$time.pod3=NA#
  }#
  if ('Outside' %in% areaTotals$Group.1){#
    temp_dat$time.out = areaTotals$x[areaTotals$Group.1 == 'Outside']    #
  } else {#
    temp_dat$time.out=NA#
  }#
  # Aggression tabulating#
  if ('x' %in% temp_dat$Ag){#
    temp_dat$any.Ag = 'Y'#
  } else {#
    temp_dat$any.Ag = 'N'#
  }#
  # for the extended Lucy example, this relied on col Q#
  # but O and P should function exactly the same#
  # Time spent (at all) _near_ others (Q)#
  temp_dat$total.near.others = sum(temp_dat$behav.length[temp_dat$X.Near.others.!=''])#
  #table(temp_dat$X.Near.others.)#
  dyad_list = aggregate(temp_dat$behav.length,by=list(temp_dat$X.Near.others.), FUN=sum)#
  indx = dim(dyad_list)[1]>1#
  temp_dat$most.near =  ifelse(indx,#
          as.character(dyad_list[2,1]),#
         NA)#
  # Time spent sitting with conspecifics#
  temp_dat$total.with.others = sum(temp_dat$behav.length[temp_dat$Sitting.with.conspecific!=''])#
  dyad_list = aggregate(temp_dat$behav.length,by=list(temp_dat$Sitting.with.conspecific.), FUN=sum)#
  indx = dim(dyad_list)[1]>1#
  temp_dat$most.sit.with =  ifelse(indx,#
                               as.character(dyad_list[2,1]),#
                               NA)#
  # Time(s) spent grooming with conspecific#
  temp_dat$total.groom.others = sum(temp_dat$behav.length[temp_dat$Grooming.with.conspecific.!=''])#
  dyad_list = aggregate(temp_dat$behav.length,by=list(temp_dat$Grooming.with.conspecific.), FUN=sum)#
  indx = dim(dyad_list)[1]>1#
  temp_dat$most.groom.with =  ifelse(indx,#
                                   as.character(dyad_list[2,1]),#
                                   NA)#
  ## Emotion - column R onwards#
  temp_dat$total.emotion.events = sum(temp_dat$Full.Display..hoots.only..or.fight.!='')#
  # filter_dat is a new df which is expanded and fit with room for current and previous events:#
  filter_dat <- NULL#
  # identifying rows with emotional events (R complete) *or* reconciliation behav.s#
  # and recording previous states where relevant#
  for (j in 2:dmtd[1]){#
    if ((temp_dat$Full.Display..hoots.only..or.fight.[j] != '') |#
     	is.na(temp_dat$Full.Display..hoots.only..or.fight.[j]) |    #
        (temp_dat$Does.focal.show.consolation.behaviour.after.a.fight.between.conspecifics.[j] != '' &#
         !is.na(temp_dat$Does.focal.show.consolation.behaviour.after.a.fight.between.conspecifics.[j]) #
        ) | #
        (temp_dat$Name.of.conspecific.s..fought.with[j] != '' &  #
         !is.na(temp_dat$Name.of.conspecific.s..fought.with[j]))#
       ){#
      filter_dat = rbind(filter_dat,cbind(temp_dat[j,],temp_dat[j-1,]))#
    }#
  }#
### below is incomplete and needs to be tailored to the preferred directory/spreadsheet setup#
#for (i in 1:length(sheets)){#
#  process_sheet(i)  # fill in later#
#}#
#temp_dat = read.csv(sheets[i], skip=1, header=TRUE)#
#temp_dat$length = as.numeric(substring(temp_dat$Time[dim(temp_dat)[1]],7))#
setwd('..')
temp_dat
temp_dat$Full.Display..hoots.only..or.fight.
table(temp_dat$Full.Display..hoots.only..or.fight.)
names(temp_dat)
table(temp_dat$Full.Display..hoots.only..or.fight.)
table(temp_dat$Does.focal.respond.)
sheets
i=73#
  temp_dat = NULL#
  temp_dat = read.csv(sheets[i], skip=1, header=TRUE)
head(temp_dat)
fill out chimp, day, start time#
  temp_dat$Chimp = temp_dat$Chimp[1]#
  temp_dat$Day = temp_dat$Day[1] # this may need to be further processed into a datetime object#
  temp_dat$Start.time = temp_dat$Start.time[1]#
  # append total length as new column and adjust final row, Time#
  # !!! this needs to be done with Date's, not numerics, otherwise the times will be wrong#
  # so the data needs to be properly standardized#
  # currently this works for Lucy 07-10 data#
  ## once Lucy 07-10 has been modified by dividing time by 60#
  temp_dat$total.length = strptime(substring(temp_dat$Time[dmtd[1]]#
                                               ,7), format='%M')#
  # same for the above guy, it needs to be a certain length string-phrase to exclude#
  # (but the numeric aspect works... for now)#
  temp_dat$Time = strptime(levels(temp_dat$Time)[temp_dat$Time],format="%H:%M:%S")#
  #temp_dat$Time = as.numeric(levels(temp_dat$Time))[temp_dat$Time] # obsolete#
  temp_dat$Time[dmtd[1]]=temp_dat$total.length[1] # may need later adjusts#
  # code time differences for all behaviors (col D)#
  for(j in 1 : dim(temp_dat)[1]-1){#
    temp_dat$behav.length[j] = difftime(temp_dat$Time[j+1],temp_dat$Time[j],units="secs")#
    # the last row has the wrong value#
  }#
  # accounting for all the state behaviors#
  temp_dat$time.Forag = sum(temp_dat$behav.length[temp_dat$Fo == 'x'])#
  temp_dat$time.RestGroom = sum(temp_dat$behav.length[temp_dat$Re.Gr == 'x'])#
  temp_dat$time.Travel = sum(temp_dat$behav.length[temp_dat$Tr == 'x'])#
  temp_dat$time.Forag = sum(temp_dat$behav.length[temp_dat$Fo == 'x'])#
  temp_dat$time.Play = sum(temp_dat$behav.length[temp_dat$Pl == 'x'])#
  temp_dat$time.Di = sum(temp_dat$behav.length[temp_dat$Di == 'x'])#
  # AlloGrooming and Aggression are handled a little differently#
  temp_dat$time.AlloGr.give = sum(temp_dat$behav.length[temp_dat$AG == 'give'])#
  temp_dat$time.AlloGr.receive = sum(temp_dat$behav.length[temp_dat$AG == 'receive'])#
  temp_dat$time.AlloGr.mutual = sum(temp_dat$behav.length[temp_dat$AG == 'mutual'])#
  temp_dat$time.AlloGr.total = temp_dat$time.AlloGr.give+temp_dat$time.AlloGr.receive+temp_dat$time.AlloGr.mutual#
  temp_dat$time.Aggress.give = sum(temp_dat$behav.length[temp_dat$Ag == 'give'])#
  temp_dat$time.Aggress.receive = sum(temp_dat$behav.length[temp_dat$Ag == 'receive'])#
  temp_dat$time.Aggress.mutual = sum(temp_dat$behav.length[temp_dat$Ag == 'mutual'])#
  temp_dat$time.Aggress.total = colSums(rbind(temp_dat$time.Aggress.give,temp_dat$time.Aggress.receive,#
                                              temp_dat$time.Aggress.mutual))#
  #summing these guys when they're full of NAs is a problem#
  # OoS totaling#
  ### TODO does not appear to be working#
  if ('x' %in% temp_dat$OS){#
    temp_dat$any.OS = 'Y'#
    temp_dat$total.OS = sum(temp_dat$behav.length[temp_dat$OS=='x'])#
  } else {#
    temp_dat$any.OS = 'N'#
    temp_dat$total.OS = NA    #
  }#
  # where does chimp spend the longest time?  #
  areaTotals = aggregate(temp_dat$behav.length, list(temp_dat$Pod), sum)#
  areaTotals = areaTotals[areaTotals$Group.1 != '',]#
  if ('1' %in% areaTotals$Group.1){#
    temp_dat$time.pod1 = areaTotals$x[areaTotals$Group.1 == '1']    #
  } else {#
    temp_dat$time.pod1=NA#
  }#
  if ('2' %in% areaTotals$Group.1){#
    temp_dat$time.pod2 = areaTotals$x[areaTotals$Group.1 == '2']    #
  } else {#
    temp_dat$time.pod2=NA#
  }#
  if ('3' %in% areaTotals$Group.1){#
    temp_dat$time.pod3 = areaTotals$x[areaTotals$Group.1 == '3']    #
  } else {#
    temp_dat$time.pod3=NA#
  }#
  if ('Outside' %in% areaTotals$Group.1){#
    temp_dat$time.out = areaTotals$x[areaTotals$Group.1 == 'Outside']    #
  } else {#
    temp_dat$time.out=NA#
  }#
  # Aggression tabulating#
  if ('x' %in% temp_dat$Ag){#
    temp_dat$any.Ag = 'Y'#
  } else {#
    temp_dat$any.Ag = 'N'#
  }#
  # for the extended Lucy example, this relied on col Q#
  # but O and P should function exactly the same#
  # Time spent (at all) _near_ others (Q)#
  temp_dat$total.near.others = sum(temp_dat$behav.length[temp_dat$X.Near.others.!=''])#
  #table(temp_dat$X.Near.others.)#
  dyad_list = aggregate(temp_dat$behav.length,by=list(temp_dat$X.Near.others.), FUN=sum)#
  indx = dim(dyad_list)[1]>1#
  temp_dat$most.near =  ifelse(indx,#
          as.character(dyad_list[2,1]),#
         NA)#
  # Time spent sitting with conspecifics#
  temp_dat$total.with.others = sum(temp_dat$behav.length[temp_dat$Sitting.with.conspecific!=''])#
  dyad_list = aggregate(temp_dat$behav.length,by=list(temp_dat$Sitting.with.conspecific.), FUN=sum)#
  indx = dim(dyad_list)[1]>1#
  temp_dat$most.sit.with =  ifelse(indx,#
                               as.character(dyad_list[2,1]),#
                               NA)#
  # Time(s) spent grooming with conspecific#
  temp_dat$total.groom.others = sum(temp_dat$behav.length[temp_dat$Grooming.with.conspecific.!=''])#
  dyad_list = aggregate(temp_dat$behav.length,by=list(temp_dat$Grooming.with.conspecific.), FUN=sum)#
  indx = dim(dyad_list)[1]>1#
  temp_dat$most.groom.with =  ifelse(indx,#
                                   as.character(dyad_list[2,1]),#
                                   NA)#
  ## Emotion - column R onwards#
  temp_dat$total.emotion.events = sum(temp_dat$Full.Display..hoots.only..or.fight.!='')#
  # filter_dat is a new df which is expanded and fit with room for current and previous events:#
  filter_dat <- NULL#
  # identifying rows with emotional events (R complete) *or* reconciliation behav.s#
  # and recording previous states where relevant#
  for (j in 2:dmtd[1]){#
    if ((temp_dat$Full.Display..hoots.only..or.fight.[j] != '') |#
     	is.na(temp_dat$Full.Display..hoots.only..or.fight.[j]) |    #
        (temp_dat$Does.focal.show.consolation.behaviour.after.a.fight.between.conspecifics.[j] != '' &#
         !is.na(temp_dat$Does.focal.show.consolation.behaviour.after.a.fight.between.conspecifics.[j]) #
        ) | #
        (temp_dat$Name.of.conspecific.s..fought.with[j] != '' &  #
         !is.na(temp_dat$Name.of.conspecific.s..fought.with[j]))#
       ){#
      filter_dat = rbind(filter_dat,cbind(temp_dat[j,],temp_dat[j-1,]))#
    }#
  }#
### below is incomplete and needs to be tailored to the preferred directory/spreadsheet setup#
#for (i in 1:length(sheets)){#
#  process_sheet(i)  # fill in later#
#}#
#temp_dat = read.csv(sheets[i], skip=1, header=TRUE)#
#temp_dat$length = as.numeric(substring(temp_dat$Time[dim(temp_dat)[1]],7))
head(temp_dat)
temp_dat
i=73#
  temp_dat = NULL#
  temp_dat = read.csv(sheets[i], skip=1, header=TRUE)
dmtd = dim(temp_dat) # this is real useful#
  # fill out chimp, day, start time#
  temp_dat$Chimp = temp_dat$Chimp[1]#
  temp_dat$Day = temp_dat$Day[1] # this may need to be further processed into a datetime object#
  temp_dat$Start.time = temp_dat$Start.time[1]#
  # append total length as new column and adjust final row, Time#
  # !!! this needs to be done with Date's, not numerics, otherwise the times will be wrong#
  # so the data needs to be properly standardized#
  # currently this works for Lucy 07-10 data#
  ## once Lucy 07-10 has been modified by dividing time by 60#
  temp_dat$total.length = strptime(substring(temp_dat$Time[dmtd[1]]#
                                               ,7), format='%M')#
  # same for the above guy, it needs to be a certain length string-phrase to exclude#
  # (but the numeric aspect works... for now)#
  temp_dat$Time = strptime(levels(temp_dat$Time)[temp_dat$Time],format="%H:%M:%S")#
  #temp_dat$Time = as.numeric(levels(temp_dat$Time))[temp_dat$Time] # obsolete#
  temp_dat$Time[dmtd[1]]=temp_dat$total.length[1] # may need later adjusts#
  # code time differences for all behaviors (col D)#
  for(j in 1 : dim(temp_dat)[1]-1){#
    temp_dat$behav.length[j] = difftime(temp_dat$Time[j+1],temp_dat$Time[j],units="secs")#
    # the last row has the wrong value#
  }#
  # accounting for all the state behaviors#
  temp_dat$time.Forag = sum(temp_dat$behav.length[temp_dat$Fo == 'x'])#
  temp_dat$time.RestGroom = sum(temp_dat$behav.length[temp_dat$Re.Gr == 'x'])#
  temp_dat$time.Travel = sum(temp_dat$behav.length[temp_dat$Tr == 'x'])#
  temp_dat$time.Forag = sum(temp_dat$behav.length[temp_dat$Fo == 'x'])#
  temp_dat$time.Play = sum(temp_dat$behav.length[temp_dat$Pl == 'x'])#
  temp_dat$time.Di = sum(temp_dat$behav.length[temp_dat$Di == 'x'])#
  # AlloGrooming and Aggression are handled a little differently#
  temp_dat$time.AlloGr.give = sum(temp_dat$behav.length[temp_dat$AG == 'give'])#
  temp_dat$time.AlloGr.receive = sum(temp_dat$behav.length[temp_dat$AG == 'receive'])#
  temp_dat$time.AlloGr.mutual = sum(temp_dat$behav.length[temp_dat$AG == 'mutual'])#
  temp_dat$time.AlloGr.total = temp_dat$time.AlloGr.give+temp_dat$time.AlloGr.receive+temp_dat$time.AlloGr.mutual#
  temp_dat$time.Aggress.give = sum(temp_dat$behav.length[temp_dat$Ag == 'give'])#
  temp_dat$time.Aggress.receive = sum(temp_dat$behav.length[temp_dat$Ag == 'receive'])#
  temp_dat$time.Aggress.mutual = sum(temp_dat$behav.length[temp_dat$Ag == 'mutual'])#
  temp_dat$time.Aggress.total = colSums(rbind(temp_dat$time.Aggress.give,temp_dat$time.Aggress.receive,#
                                              temp_dat$time.Aggress.mutual))#
  #summing these guys when they're full of NAs is a problem#
  # OoS totaling#
  ### TODO does not appear to be working#
  if ('x' %in% temp_dat$OS){#
    temp_dat$any.OS = 'Y'#
    temp_dat$total.OS = sum(temp_dat$behav.length[temp_dat$OS=='x'])#
  } else {#
    temp_dat$any.OS = 'N'#
    temp_dat$total.OS = NA    #
  }#
  # where does chimp spend the longest time?  #
  areaTotals = aggregate(temp_dat$behav.length, list(temp_dat$Pod), sum)#
  areaTotals = areaTotals[areaTotals$Group.1 != '',]#
  if ('1' %in% areaTotals$Group.1){#
    temp_dat$time.pod1 = areaTotals$x[areaTotals$Group.1 == '1']    #
  } else {#
    temp_dat$time.pod1=NA#
  }#
  if ('2' %in% areaTotals$Group.1){#
    temp_dat$time.pod2 = areaTotals$x[areaTotals$Group.1 == '2']    #
  } else {#
    temp_dat$time.pod2=NA#
  }#
  if ('3' %in% areaTotals$Group.1){#
    temp_dat$time.pod3 = areaTotals$x[areaTotals$Group.1 == '3']    #
  } else {#
    temp_dat$time.pod3=NA#
  }#
  if ('Outside' %in% areaTotals$Group.1){#
    temp_dat$time.out = areaTotals$x[areaTotals$Group.1 == 'Outside']    #
  } else {#
    temp_dat$time.out=NA#
  }#
  # Aggression tabulating#
  if ('x' %in% temp_dat$Ag){#
    temp_dat$any.Ag = 'Y'#
  } else {#
    temp_dat$any.Ag = 'N'#
  }#
  # for the extended Lucy example, this relied on col Q#
  # but O and P should function exactly the same#
  # Time spent (at all) _near_ others (Q)#
  temp_dat$total.near.others = sum(temp_dat$behav.length[temp_dat$X.Near.others.!=''])#
  #table(temp_dat$X.Near.others.)#
  dyad_list = aggregate(temp_dat$behav.length,by=list(temp_dat$X.Near.others.), FUN=sum)#
  indx = dim(dyad_list)[1]>1#
  temp_dat$most.near =  ifelse(indx,#
          as.character(dyad_list[2,1]),#
         NA)#
  # Time spent sitting with conspecifics#
  temp_dat$total.with.others = sum(temp_dat$behav.length[temp_dat$Sitting.with.conspecific!=''])#
  dyad_list = aggregate(temp_dat$behav.length,by=list(temp_dat$Sitting.with.conspecific.), FUN=sum)#
  indx = dim(dyad_list)[1]>1#
  temp_dat$most.sit.with =  ifelse(indx,#
                               as.character(dyad_list[2,1]),#
                               NA)#
  # Time(s) spent grooming with conspecific#
  temp_dat$total.groom.others = sum(temp_dat$behav.length[temp_dat$Grooming.with.conspecific.!=''])#
  dyad_list = aggregate(temp_dat$behav.length,by=list(temp_dat$Grooming.with.conspecific.), FUN=sum)#
  indx = dim(dyad_list)[1]>1#
  temp_dat$most.groom.with =  ifelse(indx,#
                                   as.character(dyad_list[2,1]),#
                                   NA)#
  ## Emotion - column R onwards#
  temp_dat$total.emotion.events = sum(temp_dat$Full.Display..hoots.only..or.fight.!='')#
  # filter_dat is a new df which is expanded and fit with room for current and previous events:#
  filter_dat <- NULL#
  # identifying rows with emotional events (R complete) *or* reconciliation behav.s#
  # and recording previous states where relevant#
  for (j in 2:dmtd[1]){#
    if ((temp_dat$Full.Display..hoots.only..or.fight.[j] != '') |#
     	is.na(temp_dat$Full.Display..hoots.only..or.fight.[j]) |    #
        (temp_dat$Does.focal.show.consolation.behaviour.after.a.fight.between.conspecifics.[j] != '' &#
         !is.na(temp_dat$Does.focal.show.consolation.behaviour.after.a.fight.between.conspecifics.[j]) #
        ) | #
        (temp_dat$Name.of.conspecific.s..fought.with[j] != '' &  #
         !is.na(temp_dat$Name.of.conspecific.s..fought.with[j]))#
       ){#
      filter_dat = rbind(filter_dat,cbind(temp_dat[j,],temp_dat[j-1,]))#
    }#
  }#
### below is incomplete and needs to be tailored to the preferred directory/spreadsheet setup#
#for (i in 1:length(sheets)){#
#  process_sheet(i)  # fill in later#
#}#
#temp_dat = read.csv(sheets[i], skip=1, header=TRUE)#
#temp_dat$length = as.numeric(substring(temp_dat$Time[dim(temp_dat)[1]],7))#
#setwd('..')
temp_dat
i=73#
  temp_dat = NULL#
  temp_dat = read.csv(sheets[i], skip=1, header=TRUE)
temp_dat
dmtd = dim(temp_dat) # this is real useful#
  # fill out chimp, day, start time#
  temp_dat$Chimp = temp_dat$Chimp[1]#
  temp_dat$Day = temp_dat$Day[1] # this may need to be further processed into a datetime object#
  temp_dat$Start.time = temp_dat$Start.time[1]#
  # append total length as new column and adjust final row, Time#
  # !!! this needs to be done with Date's, not numerics, otherwise the times will be wrong#
  # so the data needs to be properly standardized#
  # currently this works for Lucy 07-10 data#
  ## once Lucy 07-10 has been modified by dividing time by 60#
  temp_dat$total.length = strptime(substring(temp_dat$Time[dmtd[1]]#
                                               ,7), format='%M')#
  # same for the above guy, it needs to be a certain length string-phrase to exclude#
  # (but the numeric aspect works... for now)#
  temp_dat$Time = strptime(levels(temp_dat$Time)[temp_dat$Time],format="%H:%M:%S")#
  #temp_dat$Time = as.numeric(levels(temp_dat$Time))[temp_dat$Time] # obsolete#
  temp_dat$Time[dmtd[1]]=temp_dat$total.length[1] # may need later adjusts#
  # code time differences for all behaviors (col D)#
  for(j in 1 : dim(temp_dat)[1]-1){#
    temp_dat$behav.length[j] = difftime(temp_dat$Time[j+1],temp_dat$Time[j],units="secs")#
    # the last row has the wrong value#
  }#
  # accounting for all the state behaviors#
  temp_dat$time.Forag = sum(temp_dat$behav.length[temp_dat$Fo == 'x'])#
  temp_dat$time.RestGroom = sum(temp_dat$behav.length[temp_dat$Re.Gr == 'x'])#
  temp_dat$time.Travel = sum(temp_dat$behav.length[temp_dat$Tr == 'x'])#
  temp_dat$time.Forag = sum(temp_dat$behav.length[temp_dat$Fo == 'x'])#
  temp_dat$time.Play = sum(temp_dat$behav.length[temp_dat$Pl == 'x'])#
  temp_dat$time.Di = sum(temp_dat$behav.length[temp_dat$Di == 'x'])#
  # AlloGrooming and Aggression are handled a little differently#
  temp_dat$time.AlloGr.give = sum(temp_dat$behav.length[temp_dat$AG == 'give'])#
  temp_dat$time.AlloGr.receive = sum(temp_dat$behav.length[temp_dat$AG == 'receive'])#
  temp_dat$time.AlloGr.mutual = sum(temp_dat$behav.length[temp_dat$AG == 'mutual'])#
  temp_dat$time.AlloGr.total = temp_dat$time.AlloGr.give+temp_dat$time.AlloGr.receive+temp_dat$time.AlloGr.mutual#
  temp_dat$time.Aggress.give = sum(temp_dat$behav.length[temp_dat$Ag == 'give'])#
  temp_dat$time.Aggress.receive = sum(temp_dat$behav.length[temp_dat$Ag == 'receive'])#
  temp_dat$time.Aggress.mutual = sum(temp_dat$behav.length[temp_dat$Ag == 'mutual'])#
  temp_dat$time.Aggress.total = colSums(rbind(temp_dat$time.Aggress.give,temp_dat$time.Aggress.receive,#
                                              temp_dat$time.Aggress.mutual))#
  #summing these guys when they're full of NAs is a problem#
  # OoS totaling#
  ### TODO does not appear to be working#
  if ('x' %in% temp_dat$OS){#
    temp_dat$any.OS = 'Y'#
    temp_dat$total.OS = sum(temp_dat$behav.length[temp_dat$OS=='x'])#
  } else {#
    temp_dat$any.OS = 'N'#
    temp_dat$total.OS = NA    #
  }#
  # where does chimp spend the longest time?  #
  areaTotals = aggregate(temp_dat$behav.length, list(temp_dat$Pod), sum)#
  areaTotals = areaTotals[areaTotals$Group.1 != '',]#
  if ('1' %in% areaTotals$Group.1){#
    temp_dat$time.pod1 = areaTotals$x[areaTotals$Group.1 == '1']    #
  } else {#
    temp_dat$time.pod1=NA#
  }#
  if ('2' %in% areaTotals$Group.1){#
    temp_dat$time.pod2 = areaTotals$x[areaTotals$Group.1 == '2']    #
  } else {#
    temp_dat$time.pod2=NA#
  }#
  if ('3' %in% areaTotals$Group.1){#
    temp_dat$time.pod3 = areaTotals$x[areaTotals$Group.1 == '3']    #
  } else {#
    temp_dat$time.pod3=NA#
  }#
  if ('Outside' %in% areaTotals$Group.1){#
    temp_dat$time.out = areaTotals$x[areaTotals$Group.1 == 'Outside']    #
  } else {#
    temp_dat$time.out=NA#
  }#
  # Aggression tabulating#
  if ('x' %in% temp_dat$Ag){#
    temp_dat$any.Ag = 'Y'#
  } else {#
    temp_dat$any.Ag = 'N'#
  }#
  # for the extended Lucy example, this relied on col Q#
  # but O and P should function exactly the same#
  # Time spent (at all) _near_ others (Q)#
  temp_dat$total.near.others = sum(temp_dat$behav.length[temp_dat$X.Near.others.!=''])#
  #table(temp_dat$X.Near.others.)#
  dyad_list = aggregate(temp_dat$behav.length,by=list(temp_dat$X.Near.others.), FUN=sum)#
  indx = dim(dyad_list)[1]>1#
  temp_dat$most.near =  ifelse(indx,#
          as.character(dyad_list[2,1]),#
         NA)#
  # Time spent sitting with conspecifics#
  temp_dat$total.with.others = sum(temp_dat$behav.length[temp_dat$Sitting.with.conspecific!=''])#
  dyad_list = aggregate(temp_dat$behav.length,by=list(temp_dat$Sitting.with.conspecific.), FUN=sum)#
  indx = dim(dyad_list)[1]>1#
  temp_dat$most.sit.with =  ifelse(indx,#
                               as.character(dyad_list[2,1]),#
                               NA)#
  # Time(s) spent grooming with conspecific#
  temp_dat$total.groom.others = sum(temp_dat$behav.length[temp_dat$Grooming.with.conspecific.!=''])#
  dyad_list = aggregate(temp_dat$behav.length,by=list(temp_dat$Grooming.with.conspecific.), FUN=sum)#
  indx = dim(dyad_list)[1]>1#
  temp_dat$most.groom.with =  ifelse(indx,#
                                   as.character(dyad_list[2,1]),#
                                   NA)#
  ## Emotion - column R onwards#
  temp_dat$total.emotion.events = sum(temp_dat$Full.Display..hoots.only..or.fight.!='')#
  # filter_dat is a new df which is expanded and fit with room for current and previous events:#
  filter_dat <- NULL#
  # identifying rows with emotional events (R complete) *or* reconciliation behav.s#
  # and recording previous states where relevant#
  for (j in 2:dmtd[1]){#
    if ((temp_dat$Full.Display..hoots.only..or.fight.[j] != '') |#
     	is.na(temp_dat$Full.Display..hoots.only..or.fight.[j]) |    #
        (temp_dat$Does.focal.show.consolation.behaviour.after.a.fight.between.conspecifics.[j] != '' &#
         !is.na(temp_dat$Does.focal.show.consolation.behaviour.after.a.fight.between.conspecifics.[j]) #
        ) | #
        (temp_dat$Name.of.conspecific.s..fought.with[j] != '' &  #
         !is.na(temp_dat$Name.of.conspecific.s..fought.with[j]))#
       ){#
      filter_dat = rbind(filter_dat,cbind(temp_dat[j,],temp_dat[j-1,]))#
    }#
  }#
### below is incomplete and needs to be tailored to the preferred directory/spreadsheet setup#
#for (i in 1:length(sheets)){#
#  process_sheet(i)  # fill in later#
#}#
#temp_dat = read.csv(sheets[i], skip=1, header=TRUE)#
#temp_dat$length = as.numeric(substring(temp_dat$Time[dim(temp_dat)[1]],7))#
#setwd('..')
temp_dat
sheets
i=11#
  temp_dat = NULL#
  temp_dat = read.csv(sheets[i], skip=1, header=TRUE)
dmtd = dim(temp_dat) # this is real useful#
  # fill out chimp, day, start time#
  temp_dat$Chimp = temp_dat$Chimp[1]#
  temp_dat$Day = temp_dat$Day[1] # this may need to be further processed into a datetime object#
  temp_dat$Start.time = temp_dat$Start.time[1]#
  # append total length as new column and adjust final row, Time#
  # !!! this needs to be done with Date's, not numerics, otherwise the times will be wrong#
  # so the data needs to be properly standardized#
  # currently this works for Lucy 07-10 data#
  ## once Lucy 07-10 has been modified by dividing time by 60#
  temp_dat$total.length = strptime(substring(temp_dat$Time[dmtd[1]]#
                                               ,7), format='%M')#
  # same for the above guy, it needs to be a certain length string-phrase to exclude#
  # (but the numeric aspect works... for now)#
  temp_dat$Time = strptime(levels(temp_dat$Time)[temp_dat$Time],format="%H:%M:%S")#
  #temp_dat$Time = as.numeric(levels(temp_dat$Time))[temp_dat$Time] # obsolete#
  temp_dat$Time[dmtd[1]]=temp_dat$total.length[1] # may need later adjusts#
  # code time differences for all behaviors (col D)#
  for(j in 1 : dim(temp_dat)[1]-1){#
    temp_dat$behav.length[j] = difftime(temp_dat$Time[j+1],temp_dat$Time[j],units="secs")#
    # the last row has the wrong value#
  }#
  # accounting for all the state behaviors#
  temp_dat$time.Forag = sum(temp_dat$behav.length[temp_dat$Fo == 'x'])#
  temp_dat$time.RestGroom = sum(temp_dat$behav.length[temp_dat$Re.Gr == 'x'])#
  temp_dat$time.Travel = sum(temp_dat$behav.length[temp_dat$Tr == 'x'])#
  temp_dat$time.Forag = sum(temp_dat$behav.length[temp_dat$Fo == 'x'])#
  temp_dat$time.Play = sum(temp_dat$behav.length[temp_dat$Pl == 'x'])#
  temp_dat$time.Di = sum(temp_dat$behav.length[temp_dat$Di == 'x'])#
  # AlloGrooming and Aggression are handled a little differently#
  temp_dat$time.AlloGr.give = sum(temp_dat$behav.length[temp_dat$AG == 'give'])#
  temp_dat$time.AlloGr.receive = sum(temp_dat$behav.length[temp_dat$AG == 'receive'])#
  temp_dat$time.AlloGr.mutual = sum(temp_dat$behav.length[temp_dat$AG == 'mutual'])#
  temp_dat$time.AlloGr.total = temp_dat$time.AlloGr.give+temp_dat$time.AlloGr.receive+temp_dat$time.AlloGr.mutual#
  temp_dat$time.Aggress.give = sum(temp_dat$behav.length[temp_dat$Ag == 'give'])#
  temp_dat$time.Aggress.receive = sum(temp_dat$behav.length[temp_dat$Ag == 'receive'])#
  temp_dat$time.Aggress.mutual = sum(temp_dat$behav.length[temp_dat$Ag == 'mutual'])#
  temp_dat$time.Aggress.total = colSums(rbind(temp_dat$time.Aggress.give,temp_dat$time.Aggress.receive,#
                                              temp_dat$time.Aggress.mutual))#
  #summing these guys when they're full of NAs is a problem#
  # OoS totaling#
  ### TODO does not appear to be working#
  if ('x' %in% temp_dat$OS){#
    temp_dat$any.OS = 'Y'#
    temp_dat$total.OS = sum(temp_dat$behav.length[temp_dat$OS=='x'])#
  } else {#
    temp_dat$any.OS = 'N'#
    temp_dat$total.OS = NA    #
  }#
  # where does chimp spend the longest time?  #
  areaTotals = aggregate(temp_dat$behav.length, list(temp_dat$Pod), sum)#
  areaTotals = areaTotals[areaTotals$Group.1 != '',]#
  if ('1' %in% areaTotals$Group.1){#
    temp_dat$time.pod1 = areaTotals$x[areaTotals$Group.1 == '1']    #
  } else {#
    temp_dat$time.pod1=NA#
  }#
  if ('2' %in% areaTotals$Group.1){#
    temp_dat$time.pod2 = areaTotals$x[areaTotals$Group.1 == '2']    #
  } else {#
    temp_dat$time.pod2=NA#
  }#
  if ('3' %in% areaTotals$Group.1){#
    temp_dat$time.pod3 = areaTotals$x[areaTotals$Group.1 == '3']    #
  } else {#
    temp_dat$time.pod3=NA#
  }#
  if ('Outside' %in% areaTotals$Group.1){#
    temp_dat$time.out = areaTotals$x[areaTotals$Group.1 == 'Outside']    #
  } else {#
    temp_dat$time.out=NA#
  }#
  # Aggression tabulating#
  if ('x' %in% temp_dat$Ag){#
    temp_dat$any.Ag = 'Y'#
  } else {#
    temp_dat$any.Ag = 'N'#
  }#
  # for the extended Lucy example, this relied on col Q#
  # but O and P should function exactly the same#
  # Time spent (at all) _near_ others (Q)#
  temp_dat$total.near.others = sum(temp_dat$behav.length[temp_dat$X.Near.others.!=''])#
  #table(temp_dat$X.Near.others.)#
  dyad_list = aggregate(temp_dat$behav.length,by=list(temp_dat$X.Near.others.), FUN=sum)#
  indx = dim(dyad_list)[1]>1#
  temp_dat$most.near =  ifelse(indx,#
          as.character(dyad_list[2,1]),#
         NA)#
  # Time spent sitting with conspecifics#
  temp_dat$total.with.others = sum(temp_dat$behav.length[temp_dat$Sitting.with.conspecific!=''])#
  dyad_list = aggregate(temp_dat$behav.length,by=list(temp_dat$Sitting.with.conspecific.), FUN=sum)#
  indx = dim(dyad_list)[1]>1#
  temp_dat$most.sit.with =  ifelse(indx,#
                               as.character(dyad_list[2,1]),#
                               NA)#
  # Time(s) spent grooming with conspecific#
  temp_dat$total.groom.others = sum(temp_dat$behav.length[temp_dat$Grooming.with.conspecific.!=''])#
  dyad_list = aggregate(temp_dat$behav.length,by=list(temp_dat$Grooming.with.conspecific.), FUN=sum)#
  indx = dim(dyad_list)[1]>1#
  temp_dat$most.groom.with =  ifelse(indx,#
                                   as.character(dyad_list[2,1]),#
                                   NA)#
  ## Emotion - column R onwards#
  temp_dat$total.emotion.events = sum(temp_dat$Full.Display..hoots.only..or.fight.!='')#
  # filter_dat is a new df which is expanded and fit with room for current and previous events:#
  filter_dat <- NULL#
  # identifying rows with emotional events (R complete) *or* reconciliation behav.s#
  # and recording previous states where relevant#
  for (j in 2:dmtd[1]){#
    if ((temp_dat$Full.Display..hoots.only..or.fight.[j] != '') |#
     	is.na(temp_dat$Full.Display..hoots.only..or.fight.[j]) |    #
        (temp_dat$Does.focal.show.consolation.behaviour.after.a.fight.between.conspecifics.[j] != '' &#
         !is.na(temp_dat$Does.focal.show.consolation.behaviour.after.a.fight.between.conspecifics.[j]) #
        ) | #
        (temp_dat$Name.of.conspecific.s..fought.with[j] != '' &  #
         !is.na(temp_dat$Name.of.conspecific.s..fought.with[j]))#
       ){#
      filter_dat = rbind(filter_dat,cbind(temp_dat[j,],temp_dat[j-1,]))#
    }#
  }#
### below is incomplete and needs to be tailored to the preferred directory/spreadsheet setup#
#for (i in 1:length(sheets)){#
#  process_sheet(i)  # fill in later#
#}#
#temp_dat = read.csv(sheets[i], skip=1, header=TRUE)#
#temp_dat$length = as.numeric(substring(temp_dat$Time[dim(temp_dat)[1]],7))#
#setwd('..')
temp_dat
