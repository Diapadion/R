{
    "contents" : "# Detect and prevent collisions.\n# Powers dodging, stacking and filling.\ncollide <- function(data, width = NULL, name, strategy, check.width = TRUE) {\n  # Determine width\n  if (!is.null(width)) {\n    # Width set manually\n    if (!(all(c(\"xmin\", \"xmax\") %in% names(data)))) {\n      data$xmin <- data$x - width / 2\n      data$xmax <- data$x - width / 2\n    }\n  } else {\n    if (!(all(c(\"xmin\", \"xmax\") %in% names(data)))) {\n      data$xmin <- data$x\n      data$xmax <- data$x\n    }\n    \n    # Width determined from data, must be floating point constant\n    widths <- unique(data$xmax - data$xmin)\n    widths <- widths[!is.na(widths)]\n    if (!zero_range(range(widths))) {\n      warning(name, \" requires constant width: output may be incorrect\",\n              call. = FALSE)\n    }\n    width <- widths[1]\n  }\n  \n  # Reorder by x position, relying on stable sort to preserve existing\n  # ordering, which may be by group or order.\n  data <- data[order(data$xmin), ]\n  \n  # Check for overlap\n  intervals <- as.numeric(t(unique(data[c(\"xmin\", \"xmax\")])))\n  intervals <- intervals[!is.na(intervals)]\n  \n  if (length(unique(intervals)) > 1 & any(diff(scale(intervals)) < -1e-6)) {\n    warning(name, \" requires non-overlapping x intervals\", call. = FALSE)\n    # This is where the algorithm from [L. Wilkinson. Dot plots.\n    # The American Statistician, 1999.] should be used\n  }\n  \n  if (!is.null(data$ymax)) {\n    ddply(data, \"xmin\", strategy, width = width)\n  } else if (!is.null(data$y)) {\n    message(\"ymax not defined: adjusting position using y instead\")\n    \n    data$ymax <- data$y\n    data <- ddply(data, \"xmin\", strategy, width = width)\n    data$y <- data$ymax\n    data\n  } else {\n    stop(\"Neither y nor ymax defined\")\n  }\n}\n\n# Stack overlapping intervals.\n# Assumes that each set has the same horizontal position\npos_stack <- function(df, width) {\n  if (nrow(df) == 1) return(df)\n  \n  n <- nrow(df) + 1\n  y <- with(df, ifelse(is.na(y), 0, y))\n  if (all(is.na(df$x))) {\n    heights <- rep(NA, n)\n  } else {\n    heights <- c(0, cumsum(y))\n  }\n  \n  within(df, {\n    ymin <- heights[-n]\n    ymax <- heights[-1]\n    y <- ymax\n  })\n}\n\n# Stack overlapping intervals and set height to 1.\n# Assumes that each set has the same horizontal position.\npos_fill <- function(df, width) {\n  within(pos_stack(df, width), {\n    ymin <- ymin / max(ymax)\n    ymax <- ymax / max(ymax)\n    y <- ymax\n  })\n}\n\n# Dodge overlapping interval.\n# Assumes that each set has the same horizontal position.\npos_dodge <- function(df, width) {\n  n <- length(unique(df$group))\n  if (n == 1) return(df)\n  \n  if (!all(c(\"xmin\", \"xmax\") %in% names(df))) {\n    df$xmin <- df$x\n    df$xmax <- df$x\n  }\n  \n  d_width <- max(df$xmax - df$xmin)\n  diff <- width - d_width\n  \n  # df <- data.frame(n = c(2:5, 10, 26), div = c(4, 3, 2.666666,  2.5, 2.2, 2.1))\n  # qplot(n, div, data = df)\n  \n  # Have a new group index from 1 to number of groups.\n  # This might be needed if the group numbers in this set don't include all of 1:n\n  groupidx <- match(df$group, sort(unique(df$group)))\n  \n  # Find the center for each group, then use that to calculate xmin and xmax\n  df$x <- df$x + width * ((groupidx - 0.5) / n - .5)\n  df$xmin <- df$x - d_width / n / 2\n  df$xmax <- df$x + d_width / n / 2\n  \n  df\n}",
    "created" : 1428429002205.000,
    "dirty" : true,
    "encoding" : "",
    "folds" : "",
    "hash" : "1144572429",
    "id" : "67E5AC7D",
    "lastKnownWriteTime" : 578055781,
    "path" : null,
    "project_path" : null,
    "properties" : {
        "tempName" : "Untitled2"
    },
    "source_on_save" : false,
    "type" : "r_source"
}