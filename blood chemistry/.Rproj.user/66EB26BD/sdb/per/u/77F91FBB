{
    "contents" : "\n# Null default\n# Analog of || from ruby\n#\n# @keyword internal\n# @name nulldefault-infix\n\"%||%\" <- function(a, b) {\n  if (!is.null(a)) a else b\n}\n\n# Check required aesthetics are present\n# This is used by geoms and stats to give a more helpful error message\n# when required aesthetics are missing.\n#\n# @param character vector of required aesthetics\n# @param character vector of present aesthetics\n# @param name of object for error message\n# @keyword internal\ncheck_required_aesthetics <- function(required, present, name) {\n  missing_aes <- setdiff(required, present)\n  if (length(missing_aes) == 0) return()\n  \n  stop(name, \" requires the following missing aesthetics: \", paste(missing_aes, collapse=\", \"), call. = FALSE)\n}\n\n# Concatenate a named list for output\n# Print a \\code{list(a=1, b=2)} as \\code{(a=1, b=2)}\n#\n# @param list to concatenate\n# @keyword internal\n#X clist(list(a=1, b=2))\n#X clist(par()[1:5])\nclist <- function(l) {\n  paste(paste(names(l), l, sep=\" = \", collapse=\", \"), sep=\"\")\n}\n\n# Abbreviated paste\n# Alias for paste with a shorter name and convenient defaults\n#\n# @param character vectors to be concatenated\n# @param default separator\n# @param default collapser\n# @keyword internal\nps <- function(..., sep=\"\", collapse=\"\") do.call(paste, compact(list(..., sep=sep, collapse=collapse)))\n\n# Quietly try to require a package\n# Queitly require a package, returning an error message if that package is not installed.\n#\n# @param name of package\n# @keyword internal\ntry_require <- function(package) {\n  available <- suppressMessages(suppressWarnings(\n    require(package, character.only = TRUE)\n  ))\n  \n  if (!available) {\n    stop(package, \" package required for this functionality. \" ,\n         \"Please install and try again.\", call. = FALSE)\n  }\n}\n\n# Return unique columns\n# This is used for figuring out which columns are constant within a group\n#\n# @keyword internal\nuniquecols <- function(df) {\n  df <- df[1, sapply(df, function(x) length(unique(x)) == 1), drop=FALSE]\n  rownames(df) <- 1:nrow(df)\n  df\n}\n\n# A \"safe\" version of do.call\n# \\code{safe.call} works like \\code{\\link{do.call}} but it will only supply arguments that exist in the function specification.\n#\n# If ... is present in the param list, all parameters will be passed through\n# unless \\code{ignore.dots = TRUE}.  Positional arguments are not currently\n# supported.\n#\n# @param function to call\n# @arugments named list of parameters to be supplied to function\n# @param parameter names of function\n# @param\n# @keyword internal\nsafe.call <- function(f, params, f.params = names(formals(f)), ignore.dots = TRUE) {\n  if (!ignore.dots && \"...\" %in% f.params) {\n    safe.params <- params\n  } else {\n    safe.params <- params[intersect(f.params, names(params))]\n  }\n  do.call(f, safe.params)\n}\n\n# Convenience function to remove missing values from a data.frame\n# Remove all non-complete rows, with a warning if \\code{na.rm = FALSE}.\n#\n# ggplot is somewhat more accomodating of missing values than R generally.\n# For those stats which require complete data, missing values will be\n# automatically removed with a warning.  If \\code{na.rm = TRUE} is supplied\n# to the statistic, the warning will be suppressed.\n#\n# @param data.frame\n# @param suppress warning that rows are being removed?\n# @argumnets variables to check for missings in\n# @param optional function name to make warning message more informative\n# @keyword internal\n#X a <- remove_missing(movies)\n#X a <- remove_missing(movies, na.rm = TRUE)\n#X qplot(mpaa, budget, data=movies, geom=\"boxplot\")\nremove_missing <- function(df, na.rm=FALSE, vars = names(df), name=\"\", finite = FALSE) {\n  vars <- intersect(vars, names(df))\n  if (name != \"\") name <- ps(\" (\", name, \")\")\n  \n  if (finite) {\n    missing <- !finite.cases(df[, vars, drop = FALSE])\n    str <- \"non-finite\"\n  } else {\n    missing <- !complete.cases(df[, vars, drop = FALSE])\n    str <- \"missing\"\n  }\n  \n  if (any(missing)) {\n    df <- df[!missing, ]\n    if (!na.rm) warning(\"Removed \", sum(missing), \" rows containing \", str,\n                        \" values\", name, \".\", call. = FALSE)\n  }\n  \n  \n  df\n}\n\nfinite.cases <- function(x) UseMethod(\"finite.cases\")\n# Returns a logical vector of same length as nrow(x). If all data on a row\n# is finite (not NA, NaN, Inf, or -Inf) return TRUE; otherwise FALSE.\n#' @export\nfinite.cases.data.frame <- function(x) {\n  finite_cases <- vapply(x, is.finite, logical(nrow(x)))\n  \n  # Need a special case test when x has exactly one row, because rowSums\n  # doesn't respect dimensions for 1x1 matrices. vapply returns a vector (not\n  # a matrix when the input has one row.\n  if (is.vector(finite_cases)) {\n    all(finite_cases)\n  } else {\n    # Find all the rows where all are TRUE\n    rowSums(as.matrix(finite_cases)) == ncol(x)\n  }\n}\n\n\n# \"Invert\" a list\n# Keys become values, values become keys\n#\n# @param list to invert\n# @keyword internal\ninvert <- function(L) {\n  t1 <- unlist(L)\n  names(t1) <- rep(names(L), lapply(L, length))\n  tapply(names(t1), t1, c)\n}\n\n# Inside\n# Return logical vector indicating if x is inside the interval\n#\n# @keyword internal\n\"%inside%\" <- function(x, interval) {\n  x >= interval[1] & x <= interval[2]\n}\n\n#' Used in examples to illustrate when errors should occur.\n#'\n#' @param expr code to evaluate.\n#' @export\n#' @keywords internal\n#' @examples\n#' should_stop(stop(\"Hi!\"))\n#' should_stop(should_stop(\"Hi!\"))\nshould_stop <- function(expr) {\n  res <- try(print(force(expr)), TRUE)\n  if (!inherits(res, \"try-error\")) stop(\"No error!\", call. = FALSE)\n  invisible()\n}\n\n\n#' A waiver object.\n#'\n#' A waiver is a \"flag\" object, similar to \\code{NULL}, that indicates the\n#' calling function should just use the default value.  It is used in certain\n#' functions to distinguish between displaying nothing (\\code{NULL}) and\n#' displaying a default value calculated elsewhere (\\code{waiver()})\n#'\n#' @export\n#' @keywords internal\nwaiver <- function() structure(NULL, class=\"waiver\")\n\nis.waive <- function(x) inherits(x, \"waiver\")\n\n\nrescale01 <- function(x) {\n  rng <- range(x, na.rm = TRUE)\n  (x - rng[1]) / (rng[2] - rng[1])\n}\n\n# This is a hack for ggplot2 0.9.3 to make it compatible with both plyr 1.7.1 and\n# plyr 1.8 (and above). This should be removed for the next release of ggplot2.\n# Tag: deprecated\nif (packageVersion(\"plyr\") <= package_version(\"1.7.1\")) {\n  rename <- function(x, replace, warn_missing) {\n    plyr::rename(x, replace)\n  }\n} else {\n  rename <- plyr::rename\n}\n\n\n#' Give a deprecation error, warning, or messsage, depending on version number.\n#'\n#' Version numbers have the format <major>.<minor>.<subminor>, like 0.9.2.\n#' This function compares the current version number of ggplot2 against the\n#' specified \\code{version}, which is the most recent version before the\n#' function (or other object) was deprecated.\n#'\n#' \\code{gg_dep} will give an error, warning, or message, depending on the\n#' difference between the current ggplot2 version and the specified\n#' \\code{version}.\n#'\n#' If the current major number is greater than \\code{version}'s major number,\n#' or if the current minor number is more than 1 greater than \\code{version}'s\n#' minor number, give an error.\n#'\n#' If the current minor number differs from \\code{version}'s minor number by\n#' one, give a warning.\n#'\n#' If the current subminor number differs from \\code{version}'s subminor\n#' number, print a message.\n#'\n#' @param version The last version of ggplot2 where this function was good\n#'   (in other words, the last version where it was not deprecated).\n#' @param msg The message to print.\n#' @keywords internal\n#' @export\ngg_dep <- function(version, msg) {\n  v <- as.package_version(version)\n  cv <- packageVersion(\"ggplot2\")\n  \n  # If current major number is greater than last-good major number, or if\n  #  current minor number is more than 1 greater than last-good minor number,\n  #  give error.\n  if (cv[[1,1]] > v[[1,1]]  ||  cv[[1,2]] > v[[1,2]] + 1) {\n    stop(msg, \" (Defunct; last used in version \", version, \")\",\n         call. = FALSE)\n    \n    # If minor number differs by one, give warning\n  } else if (cv[[1,2]] > v[[1,2]]) {\n    warning(msg, \" (Deprecated; last used in version \", version, \")\",\n            call. = FALSE)\n    \n    # If only subminor number is greater, give message\n  } else if (cv[[1,3]] > v[[1,3]]) {\n    message(msg, \" (Deprecated; last used in version \", version, \")\")\n  }\n  \n  invisible()\n}\n",
    "created" : 1428428841861.000,
    "dirty" : true,
    "encoding" : "",
    "folds" : "",
    "hash" : "1270412212",
    "id" : "77F91FBB",
    "lastKnownWriteTime" : 578055781,
    "path" : null,
    "project_path" : null,
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}