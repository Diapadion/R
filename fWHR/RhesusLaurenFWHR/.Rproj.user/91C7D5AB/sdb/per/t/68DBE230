{
    "collab_server" : "",
    "contents" : "##############################################################\n#\n#\n#   Function to fit Penalized Mixed Model method of \n#        Bondell, Krishna, and Ghosh (2009)\n#\n#\n#\n#####################################################################\n\n\n\nPen.LME = function(y, X, Z, subject, t.fracs = seq(1,0.05,-0.05), eps = 10^(-4))\n{\n  require(MASS)\n  require(lme4)\n  require(quadprog)\n  require(mvtnorm)\n  t.fracs = sort(t.fracs,decreasing=T)\n  if (min(t.fracs) <=0) {return(cat(\"ERROR: All values for t.fracs must be > 0. \\n\"))}\n  if (max(t.fracs) >1) {return(cat(\"ERROR: All values for t.fracs must be < 1. \\n\"))}\n  if (eps <=0) {return(cat(\"ERROR: Eps must be > 0. \\n\"))}\n  \n  n.i = tabulate(subject)\n  n.tot = sum(n.i)\n  n = length(n.i)\n  Z = as.matrix(Z,nrow=n.tot)\n  Z = cbind(rep(1,n.tot), Z)\n  p = ncol(X)\n  q = ncol(Z)\t\n  \n  if (qr(X)$rank < p) {return(cat(\"ERROR: Design matrix for fixed effects is not full rank. \\n\"))}\n  if (qr(Z)$rank < q) {return(cat(\"ERROR: Design matrix for random effects is not full rank. \\n\"))}\n  \n  eps.tol = 0.00000001\n  init.fit = lmer(y ~ X -1 + (Z -1 |subject))\n  est = VarCorr(init.fit)\n  sigma.hat = (attributes(est)$sc)^2\n  \n  beta.hat=as.matrix(fixef(init.fit))\n  beta.hatp=abs(beta.hat)\n  beta.p=t(1/rbind(beta.hatp,beta.hatp))\n  D.lme = as.matrix(est$subject)/sigma.hat\n  \n  junk = t(chol(D.lme+eps.tol*diag(q)))\n  \n  lambda.hat = diag(junk)\n  lambda.hat = pmax(lambda.hat, eps.tol)\n  gamma.init = diag(as.vector(1/lambda.hat))%*%junk\n  gamma.hat = gamma.init[lower.tri(gamma.init)]\n  lambda.p = t(as.matrix(1/lambda.hat))\n  \n  Z.bd = matrix(0,nrow=(n.tot),ncol=(n*q))\n  W.bd = matrix(0,nrow=(n*q),ncol=(n*q))\n  start.point = 1\n  for (i in 1:n)\n  {\n    end.point = start.point + (n.i[i] - 1) \n    Z.bd[start.point:end.point,(q*(i-1)+1):(q*i)] = Z[start.point:end.point,]\n    start.point = end.point + 1\n  }\n  W.bd = t(Z.bd)%*%Z.bd\n  \n  new.beta = beta.hat\n  new.lambda = lambda.hat\n  new.gamma = gamma.hat\n  sigma.2.current = as.numeric(sigma.hat)\n  \n  X.star = cbind(X,-X)\n  X.star.quad = t(X.star)%*%X.star\n  \n  A.trans = rbind(diag(2*p + q), -c(beta.p,lambda.p))\n  cr.full.k = kronecker(rep(1,n),diag(q))\n  \n  ident.tilde = diag(q-1)\n  K.matrix = NULL\n  for (i in 1:(q-1))\n  {\n    for (j in 1:(q-i))\n    {\n      K.matrix = cbind(K.matrix, c(rep(0,i-1),1,rep(0,q-i-1)))\n    }\n  }\n  K.matrix=rbind(K.matrix,rep(0,q*(q-1)/2))\n  for (i in 2:(q-1))\n  {\n    ident.tilde = cbind(ident.tilde, rbind(matrix(0,nrow=i-1,ncol=q-i),diag(q-i)))\n  }\n  \n  beta.est = NULL\n  lambda.est = NULL\n  gamma.est = NULL\n  sigma.est = NULL\n  BIC.value = NULL\n  \n  for (frac in t.fracs)\n  {\n    new.beta = beta.hat\n    new.lambda = lambda.hat\n    new.gamma = gamma.hat\n    sigma.2.current = as.numeric(sigma.hat)\n    \n    t.bound = frac*(p+q)\n    b.0 = c(rep(0,2*p + q), -t.bound)\n    outer.converge = F\n    n.iter = 0\n    \n    while ((outer.converge==F) && (n.iter < 200))\n    {\n      n.iter = n.iter + 1\n      \n      beta.current = beta.iterate = new.beta\n      lambda.current = new.lambda\n      gamma.current = new.gamma\n      gamma.mat.current = diag(q)\n      gamma.mat.current[lower.tri(gamma.mat.current)] = gamma.current\n      full.gamma.mat = kronecker(diag(n),gamma.mat.current)\n      \n      n.iter1 = 0\n      inner.converge = F\n      while ((inner.converge==F) && (n.iter1 < 100))\n      {\t\n        beta.current = new.beta\n        lambda.current = new.lambda\n        n.iter1 = n.iter1 + 1\n        resid.vec.current = y-(X%*%beta.current)\n        full.gamma.mat = kronecker(diag(n),gamma.mat.current)\n        \n        full.D.mat = kronecker(diag(n),diag(as.vector(lambda.current)))\n        Cov.mat.temp = as.matrix(Z.bd%*%full.D.mat%*%full.gamma.mat)\n        sigma.2.current = as.numeric(t(resid.vec.current)%*%solve(Cov.mat.temp%*%t(Cov.mat.temp)+diag(n.tot))%*%resid.vec.current/n.tot)\n        \n        full.inv.Cov.mat = solve(t(Cov.mat.temp)%*%Cov.mat.temp + diag(n*q))\n        exp.bhat = full.inv.Cov.mat%*%t(Cov.mat.temp)%*%resid.vec.current\n        exp.Uhat = full.inv.Cov.mat*sigma.2.current\n        exp.Ghat = exp.Uhat + exp.bhat%*%t(exp.bhat)\n        \n        right.side.mat = as.matrix(Z.bd%*%diag(as.vector(full.gamma.mat%*%exp.bhat))%*%cr.full.k)\n        lower.diag.mat = as.matrix(t(cr.full.k)%*%(W.bd * (full.gamma.mat%*%exp.Ghat%*%t(full.gamma.mat)))%*%cr.full.k)\n        \n        full.right.side = as.matrix(t(X.star)%*%right.side.mat)\n        \n        D.quadratic.prog = rbind(cbind(as.matrix(X.star.quad), full.right.side),cbind(t(full.right.side), lower.diag.mat))\n        \n        d.linear.prog = as.vector(t(y)%*%cbind(as.matrix(X.star), right.side.mat))\n        \n        D.quadratic.prog = D.quadratic.prog+eps.tol*diag(nrow(D.quadratic.prog))\n        \n        beta.lambda = solve.QP(D.quadratic.prog, d.linear.prog, t(A.trans), bvec=b.0)\n        new.beta = round(beta.lambda$solution[1:p]-beta.lambda$solution[(p+1):(2*p)],6)\n        new.lambda = round(beta.lambda$solution[-(1:(2*p))],6)\n        \n        diff = abs(beta.current-new.beta)\n        if (max(c(diff))<eps) \n        {\n          inner.converge = T\n        }\n      }\n      \n      E.A = NULL\n      start.point = 1\n      d.d.t = new.lambda%*%t(new.lambda)\n      \n      full.A.t.A.matrix = 0*diag(q*(q-1)/2)\n      T.vec = rep(0,q*(q-1)/2)\n      \n      for (i in 1:n)\n      {\n        end.point = start.point + (n.i[i] - 1) \n        E.Ai = as.matrix((as.matrix(rep(1,n.i[i]),ncol=1)%*%exp.bhat[(q*(i-1)+1):(q*i)]%*%K.matrix)*(Z.bd[start.point:end.point,(q*(i-1)+2):(q*i)]%*%diag(new.lambda[-1])%*%ident.tilde))\n        E.A = rbind(E.A, E.Ai)\n        start.point = end.point + 1\n        \n        G.i = exp.Ghat[(q*(i-1)+1):(q*i),(q*(i-1)+1):(q*i)]\n        Z.Z.i = W.bd[(q*(i-1)+1):(q*i),(q*(i-1)+1):(q*i)]\n        B.matrix = as.matrix(Z.Z.i * d.d.t)\n        A.t.A.matrix = NULL\n        Cross.matrix = NULL\n        \n        for (j in 1:(q-1))\n        {\n          U.j.matrix = diag(q)[-(1:j),]\n          Cross.matrix = rbind(Cross.matrix, U.j.matrix%*%B.matrix)\n          A.t.A.row = NULL\n          for (k in 1:(q-1))\n          {\n            V.k.matrix = diag(q)[,-(1:k)]\n            A.t.A.row = cbind(A.t.A.row, U.j.matrix%*%B.matrix%*%V.k.matrix*G.i[j,k])  \n          }\n          A.t.A.matrix = rbind(A.t.A.matrix, A.t.A.row)\n        }\n        T.vec = T.vec + as.vector(((t(K.matrix)%*%G.i)*Cross.matrix)%*%rep(1,q))\n        full.A.t.A.matrix = full.A.t.A.matrix + A.t.A.matrix\n      }\n      \n      A.eigen = eigen(full.A.t.A.matrix)\n      A.eigen.vals = round(A.eigen$values,5)\n      A.eigen.vecs = A.eigen$vectors\n      eig.A = A.eigen.vals^(-1)\n      eig.A[is.infinite(eig.A)] = 0\n      \n      A.t.A.inv = (A.eigen.vecs%*%diag(eig.A)%*%t(A.eigen.vecs))\n      lin.term = t(E.A)%*%resid.vec.current-T.vec\n      new.gamma = round(A.t.A.inv%*%lin.term,6)\n      counter.1 = 1\n      for (j in 1:(q-1))\n      {\n        for (k in (j+1):q)\n        {\n          new.gamma[counter.1] = new.gamma[counter.1]*(new.lambda[j]>0)\n          counter.1 = counter.1 + 1\n        }\n      }\n      \n      diff = abs(beta.iterate-new.beta)\n      if (max(c(diff))<eps) \n      {\n        outer.converge = T\n      }\n    }\n    \n    beta.est = as.matrix(cbind(beta.est, new.beta))\n    lambda.est = as.matrix(cbind(lambda.est, new.lambda))\n    gamma.est = as.matrix(cbind(gamma.est, new.gamma))\n    resid.vec = y-(X%*%new.beta)\n    gamma.mat = diag(q)\n    gamma.mat[lower.tri(gamma.mat)] = new.gamma\n    \n    full.gamma.mat = kronecker(diag(n),gamma.mat)\n    \n    full.D.mat = kronecker(diag(n),diag(as.vector(new.lambda)))\n    Cov.mat.temp = Z.bd%*%full.D.mat%*%full.gamma.mat\n    Full.cov.mat = as.matrix(Cov.mat.temp%*%t(Cov.mat.temp)+diag(n.tot))\n    new.sigma.2 = as.numeric(t(resid.vec)%*%solve(Full.cov.mat)%*%resid.vec/n.tot)\n    \n    sigma.est = c(sigma.est, new.sigma.2)\n    Full.Cov.est = new.sigma.2*Full.cov.mat\n    Mean.est = X%*%new.beta\n    \n    loglikes = -2*(dmvnorm(as.vector(y),Mean.est,Full.Cov.est,log=TRUE))\n    df.par = sum(new.beta!=0)+sum(new.lambda!=0)*((sum(new.lambda!=0)+1)/2)\n    BIC.value = c(BIC.value, loglikes + df.par*log(n.tot))\n    \n    cat(\"Finished bound of\" ,frac,\"\\n\")\n  }\n  \n  min.BIC = which.min(BIC.value)\n  beta.BIC = beta.est[,min.BIC]\n  lambda.BIC = lambda.est[,min.BIC]\n  sigma.2.BIC = sigma.est[min.BIC]\n  gamma.BIC = gamma.est[,min.BIC]    \n  gamma.BIC.mat = diag(q)\n  gamma.BIC.mat[lower.tri(gamma.BIC.mat)] = gamma.BIC\n  temp.mat = diag(as.vector(lambda.BIC))%*%gamma.BIC.mat\n  Cov.Mat.RE = sigma.2.BIC*temp.mat%*%t(temp.mat)\n  fit = NULL\n  fit$fixed = beta.BIC\n  fit$stddev = sqrt(diag(Cov.Mat.RE))\n  fit$BIC = BIC.value\n  fit$t.frac = t.fracs[min.BIC]\n  fit$sigma.2 = sigma.2.BIC\n  fit$corr = round(diag(1/(fit$stddev+eps.tol))%*%Cov.Mat.RE%*%diag(1/(fit$stddev+eps.tol)),6)\n  \n  return(fit)\n}",
    "created" : 1495981012452.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3176904964",
    "id" : "68DBE230",
    "lastKnownWriteTime" : 1495981152,
    "last_content_update" : 1495981152770,
    "path" : "C:/Users/s1229179/GitHub/R/fWHR/RhesusLaurenFWHR/Pen.LME.r",
    "project_path" : "Pen.LME.r",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}