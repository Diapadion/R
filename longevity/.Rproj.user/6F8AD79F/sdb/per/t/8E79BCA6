{
    "contents" : "# Automatically generated from all.nw using noweb\n#tt <- function(x) x\ncoxph <- function(formula, data, weights, subset, na.action,\n        init, control, ties= c(\"efron\", \"breslow\", \"exact\"),\n        singular.ok =TRUE, robust=FALSE,\n        model=FALSE, x=FALSE, y=TRUE,  tt, method=ties, ...) {\n\n    ties <- match.arg(ties)\n    Call <- match.call()\n\n    # create a call to model.frame() that contains the formula (required)\n    #  and any other of the relevant optional arguments\n    # then evaluate it in the proper frame\n    indx <- match(c(\"formula\", \"data\", \"weights\", \"subset\", \"na.action\"),\n                  names(Call), nomatch=0) \n    if (indx[1] ==0) stop(\"A formula argument is required\")\n    temp <- Call[c(1,indx)]  # only keep the arguments we wanted\n    temp[[1]] <- as.name('model.frame')  # change the function called\n    \n    special <- c(\"strata\", \"cluster\", \"tt\")\n    temp$formula <- if(missing(data)) terms(formula, special)\n                    else              terms(formula, special, data=data)\n    # Make \"tt\" visible for coxph formulas, without making it visible elsewhere\n    if (!is.null(attr(temp$formula, \"specials\")$tt)) {\n        coxenv <- new.env(parent= environment(formula))\n        assign(\"tt\", function(x) x, env=coxenv)\n        environment(temp$formula) <- coxenv\n    }\n\n    mf <- eval(temp, parent.frame())\n    if (nrow(mf) ==0) stop(\"No (non-missing) observations\")\n    Terms <- terms(mf)\n\n    \n    ## We want to pass any ... args to coxph.control, but not pass things\n    ##  like \"dats=mydata\" where someone just made a typo.  The use of ...\n    ##  is simply to allow things like \"eps=1e6\" with easier typing\n    extraArgs <- list(...)\n    if (length(extraArgs)) {\n        controlargs <- names(formals(coxph.control)) #legal arg names\n        indx <- pmatch(names(extraArgs), controlargs, nomatch=0L)\n        if (any(indx==0L))\n            stop(gettextf(\"Argument %s not matched\", names(extraArgs)[indx==0L]),\n                 domain = NA)\n    }\n    if (missing(control)) control <- coxph.control(...)\n\n    Y <- model.extract(mf, \"response\")\n    if (!inherits(Y, \"Surv\")) stop(\"Response must be a survival object\")\n    type <- attr(Y, \"type\")\n    if (type!='right' && type!='counting')\n        stop(paste(\"Cox model doesn't support \\\"\", type,\n                          \"\\\" survival data\", sep=''))\n    data.n <- nrow(Y)   #remember this before any time transforms\n\n    if (length(attr(Terms, 'variables')) > 2) { # a ~1 formula has length 2\n        ytemp <- terms.inner(attr(Terms, 'variables')[1:2])\n        xtemp <- terms.inner(attr(Terms, 'variables')[-2])\n        if (any(!is.na(match(xtemp, ytemp))))\n            warning(\"a variable appears on both the left and right sides of the formula\")\n    }\n        \n    # The time transform will expand the data frame mf.  To do this\n    #  it needs Y and the strata.  Everything else (cluster, offset, weights)\n    #  should be extracted after the transform\n    #\n    strats <- attr(Terms, \"specials\")$strata\n    if (length(strats)) {\n        stemp <- untangle.specials(Terms, 'strata', 1)\n        if (length(stemp$vars)==1) strata.keep <- mf[[stemp$vars]]\n        else strata.keep <- strata(mf[,stemp$vars], shortlabel=TRUE)\n        strats <- as.numeric(strata.keep)\n        }\n    \n    timetrans <- attr(Terms, \"specials\")$tt\n    if (missing(tt)) tt <- NULL\n    if (length(timetrans)) {\n         timetrans <- untangle.specials(Terms, 'tt')\n         ntrans <- length(timetrans$terms)\n\n         if (is.null(tt)) {\n             tt <- function(x, time, riskset, weights){ #default to O'Brien's logit rank\n                 obrien <- function(x) {\n                     r <- rank(x)\n                     (r-.5)/(.5+length(r)-r)\n                 }\n                 unlist(tapply(x, riskset, obrien))\n             }\n         }\n         if (is.function(tt)) tt <- list(tt)  #single function becomes a list\n             \n         if (is.list(tt)) {\n             if (any(!sapply(tt, is.function))) \n                 stop(\"The tt argument must contain function or list of functions\")\n             if (length(tt) != ntrans) {\n                 if (length(tt) ==1) {\n                     temp <- vector(\"list\", ntrans)\n                     for (i in 1:ntrans) temp[[i]] <- tt[[1]]\n                     tt <- temp\n                 }\n                 else stop(\"Wrong length for tt argument\")\n             }\n         }\n         else stop(\"The tt argument must contain a function or list of functions\")\n\n         if (ncol(Y)==2) {\n             if (length(strats)==0) {\n                 sorted <- order(-Y[,1], Y[,2])\n                 newstrat <- rep.int(0L, nrow(Y))\n                 newstrat[1] <- 1L\n                 }\n             else {\n                 sorted <- order(strats, -Y[,1], Y[,2])\n                 #newstrat marks the first obs of each strata\n                 newstrat <-  as.integer(c(1, 1*(diff(strats[sorted])!=0))) \n                 }\n             if (storage.mode(Y) != \"double\") storage.mode(Y) <- \"double\"\n             counts <- .Call(Ccoxcount1, Y[sorted,], \n                             as.integer(newstrat))\n             tindex <- sorted[counts$index]\n         }\n         else {\n             if (length(strats)==0) {\n                 sort.end  <- order(-Y[,2], Y[,3])\n                 sort.start<- order(-Y[,1])\n                 newstrat  <- c(1L, rep(0, nrow(Y) -1))\n             }\n             else {\n                 sort.end  <- order(strats, -Y[,2], Y[,3])\n                 sort.start<- order(strats, -Y[,1])\n                 newstrat  <- c(1L, as.integer(diff(strats[sort.end])!=0))\n             }\n             if (storage.mode(Y) != \"double\") storage.mode(Y) <- \"double\"\n             counts <- .Call(Ccoxcount2, Y, \n                             as.integer(sort.start -1L),\n                             as.integer(sort.end -1L), \n                             as.integer(newstrat))\n             tindex <- counts$index\n         }\n         mf <- mf[tindex,]\n         Y <- Surv(rep(counts$time, counts$nrisk), counts$status)\n         type <- 'right'  # new Y is right censored, even if the old was (start, stop]\n         strats <- rep(1:length(counts$nrisk), counts$nrisk)\n         weights <- model.weights(mf)\n         if (!is.null(weights) && any(!is.finite(weights)))\n             stop(\"weights must be finite\")   \n         for (i in 1:ntrans) \n             mf[[timetrans$var[i]]] <- (tt[[i]])(mf[[timetrans$var[i]]], Y[,1], strats, \n                                                weights)\n         }\n\n    cluster<- attr(Terms, \"specials\")$cluster\n    if (length(cluster)) {\n        robust <- TRUE  #flag to later compute a robust variance\n        tempc <- untangle.specials(Terms, 'cluster', 1:10)\n        ord <- attr(Terms, 'order')[tempc$terms]\n        if (any(ord>1)) stop (\"Cluster can not be used in an interaction\")\n        cluster <- strata(mf[,tempc$vars], shortlabel=TRUE)  #allow multiples\n        dropterms <- tempc$terms  #we won't want this in the X matrix\n        # Save away xlevels after removing cluster (we don't want to save upteen\n        #  levels of that variable, which we will never need).\n        xlevels <- .getXlevels(Terms[-tempc$terms], mf)\n    }\n    else {\n        dropterms <- NULL\n        if (missing(robust)) robust <- FALSE\n        xlevels <- .getXlevels(Terms, mf)\n    }\n    \n    contrast.arg <- NULL  #due to shared code with model.matrix.coxph\n    attr(Terms, \"intercept\") <- 1\n    adrop <- 0  #levels of \"assign\" to be dropped; 0= intercept\n    stemp <- untangle.specials(Terms, 'strata', 1)\n    if (length(stemp$vars) > 0) {  #if there is a strata statement\n        hasinteractions <- FALSE\n        for (i in stemp$vars) {  #multiple strata terms are allowed\n            # The factors att has one row for each variable in the frame, one\n            #   col for each term in the model.  Pick rows for each strata\n            #   var, and find if it participates in any interactions.\n            if (any(attr(Terms, 'order')[attr(Terms, \"factors\")[i,] >0] >1))\n                hasinteractions <- TRUE  \n            }\n        if (!hasinteractions) \n            dropterms <- c(dropterms, stemp$terms)\n        else adrop <- c(0, match(stemp$var, colnames(attr(Terms, 'factors'))))\n    }\n\n    if (length(dropterms)) {\n        temppred <- attr(terms, \"predvars\")\n        Terms2 <- Terms[ -dropterms]\n        if (!is.null(temppred)) {\n            # subscripting a Terms object currently drops predvars, in error\n            attr(Terms2, \"predvars\") <- temppred[-(1+dropterms)] # \"Call\" object\n        }\n        X <- model.matrix(Terms2, mf, constrasts=contrast.arg)\n        # we want to number the terms wrt the original model matrix\n        # Do not forget the intercept, which will be a zero\n        renumber <- match(colnames(attr(Terms2, \"factors\")), \n                          colnames(attr(Terms,  \"factors\")))\n        attr(X, \"assign\") <- c(0, renumber)[1+attr(X, \"assign\")]\n    }\n    else X <- model.matrix(Terms, mf, contrasts=contrast.arg)\n\n    # drop the intercept after the fact, and also drop strata if necessary\n    Xatt <- attributes(X) \n    xdrop <- Xatt$assign %in% adrop  #columns to drop (always the intercept)\n    X <- X[, !xdrop, drop=FALSE]\n    attr(X, \"assign\") <- Xatt$assign[!xdrop]\n    #if (any(adrop>0)) attr(X, \"contrasts\") <- Xatt$contrasts[-adrop]\n    #else attr(X, \"contrasts\") <- Xatt$contrasts\n    attr(X, \"contrasts\") <- Xatt$contrasts\n    offset <- model.offset(mf)\n    if (is.null(offset) | all(offset==0)) offset <- rep(0., nrow(mf))\n    else if (any(!is.finite(offset))) stop(\"offsets must be finite\")\n        \n    weights <- model.weights(mf)\n    if (!is.null(weights) && any(!is.finite(weights)))\n        stop(\"weights must be finite\")   \n\n    assign <- attrassign(X, Terms)\n    contr.save <- attr(X, \"contrasts\")\n    if (missing(init)) init <- NULL\n    else {\n        if (length(init) != ncol(X)) stop(\"wrong length for init argument\")\n        temp <- X %*% init - sum(colMeans(X) * init)\n        if (any(temp < .Machine$double.min.exp | temp > .Machine$double.max.exp))\n            stop(\"initial values lead to overflow or underflow of the exp function\")\n    }\n    pterms <- sapply(mf, inherits, 'coxph.penalty')\n    if (any(pterms)) {\n        pattr <- lapply(mf[pterms], attributes)\n        pname <- names(pterms)[pterms]\n        # \n        # Check the order of any penalty terms\n        ord <- attr(Terms, \"order\")[match(pname, attr(Terms, 'term.labels'))]\n        if (any(ord>1)) stop ('Penalty terms cannot be in an interaction')\n        pcols <- assign[match(pname, names(assign))] \n        \n        fit <- coxpenal.fit(X, Y, strats, offset, init=init,\n                            control,\n                            weights=weights, method=method,\n                            row.names(mf), pcols, pattr, assign)\n    }\n    else {\n        if( method==\"breslow\" || method ==\"efron\") {\n            if (type== 'right')  fitter <- get(\"coxph.fit\")\n            else                 fitter <- get(\"agreg.fit\")\n        }\n        else if (method=='exact') {\n            if (type== \"right\")  fitter <- get(\"coxexact.fit\")\n            else  fitter <- get(\"agexact.fit\")\n        }\n        else stop(paste (\"Unknown method\", method))\n\n        fit <- fitter(X, Y, strats, offset, init, control, weights=weights,\n                      method=method, row.names(mf))\n    }\n    if (is.character(fit)) {\n        fit <- list(fail=fit)\n        class(fit) <- 'coxph'\n    }\n    else {\n        if (!is.null(fit$coefficients) && any(is.na(fit$coefficients))) {\n           vars <- (1:length(fit$coefficients))[is.na(fit$coefficients)]\n           msg <-paste(\"X matrix deemed to be singular; variable\",\n                           paste(vars, collapse=\" \"))\n           if (singular.ok) warning(msg)\n           else             stop(msg)\n        }\n        fit$n <- data.n\n        fit$nevent <- sum(Y[,ncol(Y)])\n        fit$terms <- Terms\n        fit$assign <- assign\n        class(fit) <- fit$method        \n\n        if (robust) {\n            fit$naive.var <- fit$var\n            fit$method    <- method\n            # a little sneaky here: by calling resid before adding the\n            #   na.action method, I avoid having missings re-inserted\n            # I also make sure that it doesn't have to reconstruct X and Y\n            fit2 <- c(fit, list(x=X, y=Y, weights=weights))\n            if (length(strats)) fit2$strata <- strats\n            if (length(cluster)) {\n                temp <- residuals.coxph(fit2, type='dfbeta', collapse=cluster,\n                                          weighted=TRUE)\n                # get score for null model\n                if (is.null(init))\n                        fit2$linear.predictors <- 0*fit$linear.predictors\n                else fit2$linear.predictors <- c(X %*% init)\n                temp0 <- residuals.coxph(fit2, type='score', collapse=cluster,\n                                         weighted=TRUE)\n        }\n            else {\n                temp <- residuals.coxph(fit2, type='dfbeta', weighted=TRUE)\n                fit2$linear.predictors <- 0*fit$linear.predictors\n                temp0 <- residuals.coxph(fit2, type='score', weighted=TRUE)\n        }\n            fit$var <- t(temp) %*% temp\n            u <- apply(as.matrix(temp0), 2, sum)\n            fit$rscore <- coxph.wtest(t(temp0)%*%temp0, u, control$toler.chol)$test\n        }\n        #Wald test\n        if (length(fit$coefficients) && is.null(fit$wald.test)) {  \n            #not for intercept only models, or if test is already done\n            nabeta <- !is.na(fit$coefficients)\n            # The init vector might be longer than the betas, for a sparse term\n            if (is.null(init)) temp <- fit$coefficients[nabeta]\n            else temp <- (fit$coefficients - \n                          init[1:length(fit$coefficients)])[nabeta]\n            fit$wald.test <-  coxph.wtest(fit$var[nabeta,nabeta], temp,\n                                          control$toler.chol)$test\n        }\n        na.action <- attr(mf, \"na.action\")\n        if (length(na.action)) fit$na.action <- na.action\n        if (model) {\n            if (length(timetrans)) {\n                # Fix up the model frame -- still in the thinking stage\n                mf[[\".surv.\"]]   <- Y\n                mf[[\".strata.\"]] <- strats\n                stop(\"Time transform + model frame: code incomplete\")\n            }\n            fit$model <- mf\n        }\n        if (x)  {\n            fit$x <- X\n            if (length(strats)) {\n                if (length(timetrans)) fit$strata <- strats\n                else     fit$strata <- strata.keep\n            }\n        }\n        if (y)     fit$y <- Y\n    }\n    if (!is.null(weights) && any(weights!=1)) fit$weights <- weights\n    names(fit$means) <- names(fit$coefficients)\n\n    fit$formula <- formula(Terms)\n    if (length(xlevels) >0) fit$xlevels <- xlevels\n    fit$contrasts <- contr.save\n    if (any(offset !=0)) fit$offset <- offset\n    fit$call <- Call\n    fit$method <- method\n    fit\n    }\n",
    "created" : 1448401148610.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2568131553",
    "id" : "8E79BCA6",
    "lastKnownWriteTime" : 1448403829,
    "path" : "~/GitHub/R/longevity/coxph.R",
    "project_path" : "coxph.R",
    "properties" : {
    },
    "relative_order" : 11,
    "source_on_save" : false,
    "type" : "r_source"
}