{
    "collab_server" : "",
    "contents" : "### Decision tree analyses\n\n\n\n#library(party)\nlibrary(partykit)\nlibrary(LTRCtrees)\nlibrary(rpart.plot)\nlibrary(ipred)\nlibrary(survival)\n\n\n\ndatX$sex = as.factor(datX$sex)\nlevels(datX$sex) = c('Female','Male')\n\n\ncit.1 = LTRCIT(Surv(age_pr, age, status) ~ \n                 sex + as.factor(origin) +  \n                 Dom_CZ + Ext_CZ + Con_CZ + Agr_CZ + Neu_CZ + Opn_CZ,\n               data=datX)\n\ncit.1.x = LTRCIT(Surv(age_pr, age, status) ~ \n                   # as.factor(sex) + as.factor(origin) +  \n                   Dom_CZ + Ext_CZ + Con_CZ + Agr_CZ + Neu_CZ + Opn_CZ,\n                 data=datX)\n\n\ncit.2 = LTRCIT(Surv(age_pr, age, status) ~ \n                 as.factor(sex) + as.factor(origin) +  \n                 D.r2.DoB + E.r2.DoB + Con_CZ + Agr_CZ + N.r1.DoB + O.r2.DoB,\n               data=datX)\n\ncit.2.x = LTRCIT(Surv(age_pr, age, status) ~ \n                   # as.factor(sex) + as.factor(origin) +  \n                   D.r2.DoB + E.r2.DoB + Con_CZ + Agr_CZ + N.r1.DoB + O.r2.DoB,\n                 data=datX)\n\n\n\n#plot(irisct, gp = gpar(fontsize = 20)) \nplot(cit.1, gp = gpar(fontfamily='serif',fontsize = 15),\n     inner_panel=node_inner,\n     ip_args=list(\n       abbreviate = F, \n       id = FALSE),\n     # edge_panel=node_surv,\n     # ep_args = list(\n     #   id = F)\n     )\n\nprint(cit.1.x)\n\n\n### Random forest\n\ncif.1 = cforest(Surv(age_pr, age, status) ~ \n                  as.factor(sex) + as.factor(origin) +  \n                  Dom_CZ + Ext_CZ + Con_CZ + Agr_CZ + Neu_CZ + Opn_CZ,\n                control = cforest_control(mincriterion = 0.1),\n                data=datX)\n\n\npt <- prettytree(cif.1@ensemble[[90]], names(cif.1@data@get(\"input\"))) \nnt <- new(\"BinaryTree\") \nnt@tree <- pt \nnt@data <- cif.1@data \nnt@responses <- cif.1@responses \n\nplot(nt)\n\ncforestImpPlot <- function(x) {\n  cforest_importance <<- v <- varimp(x)\n  dotchart(v[order(v)])\n}\n\n\ncforestImpPlot(cif.1)\n\nvarimp(cif.1)\n\n\nimportance(cif.1)\n\n###\n\n\n\n\n#cit.1.pred = predict(cit.1, newdata=datX, type = 'prob')\n\nrrt.1 = LTRCART(Surv(age_pr, age, status) ~\n                  as.factor(sex) + as.factor(origin) +\n                  Dom_CZ + Ext_CZ + Con_CZ + Agr_CZ + Neu_CZ + Opn_CZ,\n                data=datX)\nrpart.plot(rrt.1)\ntext(rrt.1)\n\n\n\n\n# cv.rrt.1 = validate(rrt.1, data=datX)\n\n\nhttp://luisdva.github.io/Plotting-conditional-inference-trees-in-R/\n\n\n  \n  \n  \n# library(rms)\n\n\n\nlibrary(randomForest) #SRC)\n\nrf.1 <- rfsrc(Surv(age, status) ~ \n                as.factor(sex) + as.factor(origin) +  \n                #Dom_CZ + Ext_CZ + Con_CZ + Agr_CZ + Neu_CZ + Opn_CZ,\n              D.r2.DoB + E.r2.DoB + Con_CZ + Agr_CZ + N.r1.DoB + O.r2.DoB,\n              nsplit = 10, ntree=100, data=datX)\nprint(rf.1)\nplot(rf.1)\nmatplot(rf.1$time.interest, 100 * t(rf.1$survival[1:10, ]),\n        xlab = \"Time\", ylab = \"Survival\", type = \"l\", lty = 1)\nplot.survival(rf.1, subset = 1:10, haz.model='ggamma')\n\nset.seed(779)\nvsel = var.select(Surv(age, status) ~\n                    as.factor(sex) + as.factor(origin) +\n                    Dom_CZ + Ext_CZ + Con_CZ + Agr_CZ + Neu_CZ + Opn_CZ,\n                  conservative = 'high', sub.order =T,\n                  data=datX)\nvsel = var.select(Surv(age, status) ~\n                    as.factor(sex) + as.factor(origin) +\n                    #Dom_CZ + Ext_CZ + Con_CZ + Agr_CZ + Neu_CZ + Opn_CZ,\n                    D.r2.DoB + E.r2.DoB + Con_CZ + Agr_CZ + N.r1.DoB + O.r2.DoB,\n                  conservative = 'high', sub.order =T,\n                  data=datX)\n\n#vsel = max.subtree(rf.1, max.order = 3, sub.order = T)\n\n\nplot.variable(rf.1, c(\"Dom_CZ\",\"Ext_CZ\",\"Con_CZ\",\"Neu_CZ\",\"Agr_CZ\",\"Opn_CZ\"))\n\n\n\n\n\n\n### some figures aggreagated from __\n\nIT.bin.x1 = c(99.9, 100, 100, 99.9, 100, 100)\nIT.bin.x2 = c(100, 99.9, 100, 100, 100, 100)\n\nART.bin.x1 = c(98, 99.9, 100, 98.9, 99.9, 100)\nART.bin.x2 = c(99.9, 99.5, 100, 100, 100, 100)\n\nIT.cont.x1 = c(99.9, 100, 100, 99.9, 99.9, 100)\nIT.cont.x2 = c(99.7, 87.6, 100, 100, 98, 100)\n\nART.cont.x1 = c(95.7, 99.9, 100, 97.3, 99.4, 100)\nART.cont.x2 = c(99.8, 99.2, 100, 100, 99.6, 100)\n\n\nmean(c(IT.bin.x1,IT.bin.x2,IT.cont.x1,IT.cont.x2))\nmean(c(ART.bin.x1,ART.bin.x2,ART.cont.x1,ART.cont.x2))\n\n\n\n### Nice plots\n\nplot (cit.1,inner_panel=innerWeights,\n#      terminal_panel=node_barplot2,\n      tp_args = list(ylines = c(2, 4)))\n\n\n\n### Plotting helper functions\n\n# custom barplot function to alter the appearance of terminal nodes\n# modified from code provided by Achim Zeileis to the R-help mailing list \n# source the function and assign it as a grapcon_generator object\nnode_barplot2 <- function(ctreeobj,\n                          col = \"black\",\n                          fill = c(\"red\", \"white\"),\n                          beside = NULL,\n                          ymax = NULL,\n                          ylines = NULL,\n                          widths = 1,\n                          gap = NULL,\n                          reverse = NULL,\n                          id = TRUE)\n{\n  getMaxPred <- function(x) {\n    mp <- max(x$prediction)\n    mpl <- ifelse(x$terminal, 0, getMaxPred(x$left))\n    mpr <- ifelse(x$terminal, 0, getMaxPred(x$right))\n    return(max(c(mp, mpl, mpr)))\n  }\n  \n  y <- response(ctreeobj)[[1]]\n  \n  if(is.factor(y) || class(y) == \"was_ordered\") {\n    ylevels <- levels(y)\n    if(is.null(beside)) beside <- if(length(ylevels) < 3) FALSE else TRUE\n    if(is.null(ymax)) ymax <- if(beside) 1.1 else 1\n    if(is.null(gap)) gap <- if(beside) 0.1 else 0\n  } else {\n    if(is.null(beside)) beside <- FALSE\n    if(is.null(ymax)) ymax <- getMaxPred(ctreeobj @ tree) * 1.1\n    ylevels <- seq(along = ctreeobj @ tree$prediction)\n    if(length(ylevels) < 2) ylevels <- \"\"\n    if(is.null(gap)) gap <- 1\n  }\n  if(is.null(reverse)) reverse <- !beside\n  if(is.null(fill)) fill <- gray.colors(length(ylevels))\n  if(is.null(ylines)) ylines <- if(beside) c(3, 4) else c(1.5, 2.5)\n  \n  ### panel function for barplots in nodes\n  rval <- function(node) {\n    \n    ## parameter setup\n    pred <- node$prediction\n    if(reverse) {\n      pred <- rev(pred)\n      ylevels <- rev(ylevels)\n    }\n    np <- length(pred)\n    nc <- if(beside) np else 1\n    \n    fill <- rep(fill, length.out = np)\n    widths <- rep(widths, length.out = nc)\n    col <- rep(col, length.out = nc)\n    ylines <- rep(ylines, length.out = 2)\n    \n    gap <- gap * sum(widths)\n    yscale <- c(0, ymax)\n    xscale <- c(0, sum(widths) + (nc+1)*gap)\n    \n    top_vp <- viewport(layout = grid.layout(nrow = 2, ncol = 3,\n                                            widths = unit(c(ylines[1], 1, ylines[2]), c(\"lines\", \"null\", \"lines\")),\n                                            heights = unit(c(3.5,3.5), c(\"lines\", \"null\"))),\n                       width = unit(1, \"npc\"),\n                       height = unit(1, \"npc\") - unit(2, \"lines\"),\n                       name = paste(\"node_barplot\", node$nodeID, sep = \"\"))\n    \n    pushViewport(top_vp)\n    grid.rect(gp = gpar(fill = \"white\", col = 0))\n    \n    ## main title\n    top <- viewport(layout.pos.col=2, layout.pos.row=1)\n    pushViewport(top)\n    mainlab <- paste(ifelse(id, paste(\"Node\", node$nodeID,\"\\n\", \"(n = \"), \"n = \"),\n                     sum(node$weights), ifelse(id, \")\", \"\"), sep = \"\")\n    grid.text(mainlab)\n    popViewport()\n    \n    plot <- viewport(layout.pos.col=2, layout.pos.row=2,\n                     xscale=xscale, yscale=yscale,\n                     name = paste(\"node_barplot\", node$nodeID, \"plot\",\n                                  sep = \"\"))\n    \n    pushViewport(plot)\n    \n    if(beside) {\n      xcenter <- cumsum(widths+gap) - widths/2\n      for (i in 1:np) {\n        grid.rect(x = xcenter[i], y = 0, height = pred[i],\n                  width = widths[i],\n                  just = c(\"center\", \"bottom\"), default.units = \"native\",\n                  gp = gpar(col = col[i], fill = fill[i]))\n      }\n      if(length(xcenter) > 1) grid.xaxis(at = xcenter, label = FALSE)\n      grid.text(ylevels, x = xcenter, y = unit(-1, \"lines\"),\n                default.units = \"native\",\n                just= c(\"center\",\"bottom\"),\n                check.overlap = TRUE)\n      grid.yaxis()\n    } else {\n      ycenter <- cumsum(pred) - pred\n      \n      for (i in 1:np) {\n        grid.rect(x = xscale[2]/2, y = ycenter[i], height = min(pred[i], ymax - ycenter[i]),\n                  width = widths[1],\n                  just = c(\"center\", \"bottom\"), default.units = \"native\",\n                  gp = gpar(col = col[i], fill = fill[i]))\n      }\n      \n      grid.yaxis(at = round(1 - pred[i], digits = 2), main = FALSE)\n    }\n    \n    grid.rect(gp = gpar(fill = \"transparent\"))\n    upViewport(2)\n  }\n  \n  return(rval)\n}\nclass(node_barplot2) <- \"grapcon_generator\"\n\n# custom function by user \"agstudy\"\n# draws a white circle with the node name and the number of obs.\n# innerWeights <- function(node){\n#   grid.circle(r=0.36,gp = gpar(fill = \"White\",col=\"White\"))\n#   mainlab <- paste( node$psplit$variableName, \"\\n(n = \")\n#   mainlab <- paste(mainlab, sum(node$weights),\")\" , sep = \"\")\n#   grid.text(mainlab,gp = gpar(col='black'))\n# }\n\ninnerWeights <- function(node){\n  grid.circle(gp = gpar(fill = \"White\", col = 'black'))\n  mainlab <- paste(node$psplit$variableName, \"\\n(n = \")\n  mainlab <- paste(mainlab, sum(node$weights),\")\" , sep = \"\")\n  grid.text(mainlab,gp = gpar(col='black'))\n}\n",
    "created" : 1489664597167.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "640743284",
    "id" : "28D78B54",
    "lastKnownWriteTime" : 1490185203,
    "last_content_update" : 1490185203332,
    "path" : "C:/Users/s1229179/GitHub/R/longevity/trees.R",
    "project_path" : "trees.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 9,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}